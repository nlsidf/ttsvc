<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½è¯­éŸ³åˆæˆç³»ç»Ÿ - ä¸€é”®éŸ³è‰²å…‹éš†ï¼ˆå¸¦æµå¼è¿›åº¦ï¼‰</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Bootstrap Icons å·²ç¦ç”¨ï¼ˆCORS é—®é¢˜ï¼‰ï¼Œä½¿ç”¨ emoji å’Œ text æ›¿ä»£ -->
    <style>
        /* å›¾æ ‡å¤‡ç”¨æ ·å¼ */
        [class*="bi-"]::before {
            font-family: inherit;
            font-style: normal;
            font-weight: 400;
            line-height: 1;
            margin-right: 0.5rem;
        }
    </style>
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --success-gradient: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            --warning-gradient: linear-gradient(135deg, #f7971e 0%, #ffd200 100%);
            --info-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
        }

        body {
            background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
            min-height: 100vh;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .main-header {
            background: var(--primary-gradient);
            color: white;
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
        }

        .step-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }

        .step-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
        }

        .step-card.active {
            border-color: #667eea;
        }

        .step-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #f0f0f0;
        }

        .step-icon {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--primary-gradient);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            margin-right: 15px;
            flex-shrink: 0;
        }

        .step-title {
            font-size: 1.4em;
            font-weight: 600;
            color: #333;
            margin: 0;
        }

        .step-subtitle {
            color: #666;
            font-size: 0.95em;
            margin-top: 5px;
        }

        .upload-box {
            border: 3px dashed #ddd;
            border-radius: 12px;
            padding: 40px 20px;
            text-align: center;
            background: #f8f9fa;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .upload-box:hover, .upload-box.dragover {
            border-color: #667eea;
            background: #f0f0ff;
        }

        .upload-icon {
            font-size: 3em;
            color: #667eea;
            margin-bottom: 15px;
        }

        .audio-preview {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }

        .audio-preview audio {
            width: 100%;
            border-radius: 8px;
        }

        .control-slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        /* WebKit/Blink (Chrome, Safari, Edge) */
        .control-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Firefox */
        .control-slider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            border: none;
        }

        .param-value {
            font-weight: bold;
            color: #667eea;
            font-size: 1.2em;
            min-width: 40px;
            display: inline-block;
            text-align: center;
        }

        .status-badge {
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
        }

        .status-badge .badge-icon {
            margin-right: 8px;
            font-size: 1.1em;
        }

        .status-loading {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffc107;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #28a745;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #dc3545;
        }

        .action-button {
            padding: 15px 40px;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            font-size: 1.2em;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .action-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .btn-generate {
            background: var(--primary-gradient);
            color: white;
            font-size: 1.3em;
            padding: 18px 50px;
        }

        .btn-generate:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn-download {
            background: var(--success-gradient);
            color: white;
        }

        .btn-download:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(17, 153, 142, 0.4);
        }

        .progress-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.1);
        }

        .progress-bar-container {
            height: 30px;
            border-radius: 15px;
            background: #e9ecef;
            overflow: hidden;
            margin-bottom: 10px;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .result-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.08);
            border-left: 5px solid #28a745;
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .result-header {
            color: #28a745;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .workflow-diagram {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 30px 0;
            position: relative;
        }

        .workflow-step {
            text-align: center;
            flex: 1;
            position: relative;
            z-index: 2;
        }

        .workflow-icon {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8em;
            color: #667eea;
            margin: 0 auto 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border: 3px solid #f0f0f0;
        }

        .workflow-step.active .workflow-icon {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .workflow-step.completed .workflow-icon {
            background: #28a745;
            color: white;
            border-color: #28a745;
        }

        .workflow-arrow {
            flex: 1;
            text-align: center;
            color: #667eea;
            font-size: 1.5em;
            position: relative;
            z-index: 1;
        }

        .workflow-line {
            position: absolute;
            top: 35px;
            left: 85px;
            right: 85px;
            height: 4px;
            background: #f0f0f0;
            z-index: 1;
        }

        .streaming-info {
            background: #e8f4f8;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #4facfe;
            display: none;
        }

        .streaming-info h6 {
            color: #2c3e50;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .segment-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
            padding-right: 5px;
        }

        .segment-list::-webkit-scrollbar {
            width: 6px;
        }

        .segment-list::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .segment-list::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 3px;
        }

        .segment-item {
            background: white;
            border-radius: 8px;
            padding: 12px 15px;
            margin-bottom: 10px;
            border-left: 4px solid #dee2e6;
            transition: all 0.3s ease;
        }

        .segment-item:hover {
            transform: translateX(3px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }

        .segment-item.processed {
            border-left-color: #28a745;
            background: #f0fff4;
        }

        .segment-item.processing {
            border-left-color: #ffc107;
            background: #fff8e1;
        }

        .segment-item.pending {
            border-left-color: #dee2e6;
            background: #f8f9fa;
        }

        .segment-item.error {
            border-left-color: #dc3545;
            background: #f8d7da;
        }

        .segment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .segment-title {
            font-weight: 600;
            color: #333;
        }

        .segment-badge {
            font-size: 0.75em;
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: 600;
        }

        .segment-details {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
        }

        .service-badge {
            background: #e9ecef;
            border-radius: 20px;
            padding: 8px 15px;
            font-size: 0.85em;
            color: #666;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .service-online {
            background: #d4edda;
            color: #155724;
        }

        .service-offline {
            background: #f8d7da;
            color: #721c24;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
            margin: 15px 0;
        }

        .file-info {
            margin-top: 10px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .example-btn {
            font-size: 0.85rem;
            padding: 5px 10px;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .settings-panel {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #dee2e6;
        }

        .toggle-advanced {
            color: #667eea;
            cursor: pointer;
            font-size: 0.9em;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .advanced-options {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px dashed #dee2e6;
        }

        .quick-settings {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .quick-setting-item {
            flex: 1;
            min-width: 120px;
        }

        .status-message {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 3px 15px rgba(0,0,0,0.05);
        }

        .processing-steps {
            margin-top: 20px;
        }

        .processing-step {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
            padding: 10px;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .processing-step.completed {
            background: #d4edda;
        }

        .processing-step.active {
            background: #fff3cd;
        }

        .step-check {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #dee2e6;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 12px;
            font-size: 0.9em;
        }

        .processing-step.completed .step-check {
            background: #28a745;
            color: white;
        }

        .processing-step.active .step-check {
            background: #ffc107;
            color: white;
        }

        .one-click-section {
            text-align: center;
            margin: 30px 0;
        }

        .file-status {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
            background: #f8f9fa;
        }

        .file-status.ready {
            background: #d4edda;
            border-left: 4px solid #28a745;
        }

        .file-status.pending {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
        }

        .file-status-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
        }

        .file-status.ready .file-status-icon {
            background: #28a745;
            color: white;
        }

        .file-status.pending .file-status-icon {
            background: #ffc107;
            color: white;
        }

        .streaming-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.85em;
            color: #666;
        }

        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .main-header {
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .main-header h1 {
                font-size: 1.8em;
            }
            
            .step-card {
                padding: 15px;
                margin-bottom: 15px;
            }
            
            .step-icon {
                width: 40px;
                height: 40px;
                font-size: 1.2em;
                margin-right: 10px;
            }
            
            .step-title {
                font-size: 1.1em;
            }
            
            #audio-enable-prompt {
                margin-bottom: 20px;
                animation: pulse 2s infinite;
            }
            
            @keyframes pulse {
                0%, 100% {
                    box-shadow: 0 0 0 0 rgba(13, 110, 253, 0.4);
                }
                50% {
                    box-shadow: 0 0 0 10px rgba(13, 110, 253, 0);
                }
            }
            
            .upload-box {
                padding: 30px 15px;
            }
            
            .upload-icon {
                font-size: 2em;
            }
            
            .action-button {
                padding: 12px 30px;
                font-size: 1em;
            }
            
            .btn-generate {
                font-size: 1.1em;
                padding: 15px 35px;
            }
            
            .workflow-diagram {
                margin: 20px 0;
            }
            
            .workflow-icon {
                width: 50px;
                height: 50px;
                font-size: 1.4em;
            }
            
            .workflow-step h6 {
                font-size: 0.8em;
            }
            
            .quick-settings {
                flex-direction: column;
            }
            
            .quick-setting-item {
                min-width: 100%;
            }
            
            .segment-item {
                padding: 10px;
            }
            
            .segment-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }
            
            .streaming-stats {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .stat-card {
                padding: 10px;
            }
            
            .stat-value {
                font-size: 1.2em;
            }
            
            .progress-bar-container {
                height: 25px;
            }
            
            .processing-step {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .processing-step .step-check {
                margin-bottom: 10px;
            }
        }

        /* è§¦æ‘¸ä¼˜åŒ– */
        @media (hover: none) and (pointer: coarse) {
            .action-button,
            .btn-generate,
            .btn-download {
                min-height: 48px; /* iOS æ¨èçš„æœ€å°è§¦æ‘¸ç›®æ ‡ */
            }
            
            .control-slider {
                height: 12px;
            }
            
            .control-slider::-webkit-slider-thumb {
                width: 28px;
                height: 28px;
            }
            
            .upload-box,
            .example-btn {
                min-height: 44px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ä¸»æ ‡é¢˜ -->
        <div class="main-header">
            <div class="row align-items-center">
                <div class="col-md-8">
                    <h1 class="display-5 fw-bold mb-3">ğŸ¤ æ™ºèƒ½è¯­éŸ³åˆæˆç³»ç»Ÿ</h1>
                    <p class="lead mb-0">ä¸€é”®ç”Ÿæˆå…‹éš†è¯­éŸ³ - å®æ—¶æ˜¾ç¤ºæµå¼å¤„ç†è¿›åº¦</p>
                </div>
                <div class="col-md-4 text-end">
                    <div class="service-badge service-online mb-2" id="tts-service-status">
                        <i class="bi bi-check-circle-fill"></i>
                        TTSæœåŠ¡åœ¨çº¿
                    </div>
                    <div class="service-badge service-online" id="isv-service-status">
                        <i class="bi bi-check-circle-fill"></i>
                        éŸ³è‰²å…‹éš†æœåŠ¡åœ¨çº¿
                    </div>
                </div>
            </div>
        </div>

        <!-- ç§»åŠ¨ç«¯éŸ³é¢‘å¯ç”¨æç¤º -->
        <div class="alert alert-info d-flex align-items-center" id="audio-enable-prompt" style="display: none;">
            <i class="bi bi-volume-up fs-4 me-3"></i>
            <div class="flex-grow-1">
                <strong>å¯ç”¨éŸ³é¢‘åŠŸèƒ½</strong>
                <p class="mb-0">ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¯ç”¨éŸ³é¢‘æ’­æ”¾åŠŸèƒ½ï¼ˆç§»åŠ¨ç«¯å¿…éœ€ï¼‰</p>
            </div>
            <button class="btn btn-primary" id="enable-audio-btn">
                <i class="bi bi-play-circle"></i> ç‚¹å‡»å¯ç”¨
            </button>
        </div>

        <!-- å·¥ä½œæµç¨‹å›¾ç¤º -->
        <div class="workflow-diagram">
            <div class="workflow-line"></div>
            <div class="workflow-step active" id="step1-wf">
                <div class="workflow-icon">
                    <i class="bi bi-chat-square-text"></i>
                </div>
                <h6 class="mb-0">è¾“å…¥æ–‡æœ¬</h6>
            </div>
            <div class="workflow-arrow">
                <i class="bi bi-arrow-right"></i>
            </div>
            <div class="workflow-step" id="step2-wf">
                <div class="workflow-icon">
                    <i class="bi bi-mic"></i>
                </div>
                <h6 class="mb-0">ä¸Šä¼ éŸ³è‰²</h6>
            </div>
            <div class="workflow-arrow">
                <i class="bi bi-arrow-right"></i>
            </div>
            <div class="workflow-step" id="step3-wf">
                <div class="workflow-icon">
                    <i class="bi bi-gear"></i>
                </div>
                <h6 class="mb-0">è®¾ç½®å‚æ•°</h6>
            </div>
            <div class="workflow-arrow">
                <i class="bi bi-arrow-right"></i>
            </div>
            <div class="workflow-step" id="step4-wf">
                <div class="workflow-icon">
                    <i class="bi bi-magic"></i>
                </div>
                <h6 class="mb-0">ç”Ÿæˆå…‹éš†</h6>
            </div>
            <div class="workflow-arrow">
                <i class="bi bi-arrow-right"></i>
            </div>
            <div class="workflow-step" id="step5-wf">
                <div class="workflow-icon">
                    <i class="bi bi-file-earmark-music"></i>
                </div>
                <h6 class="mb-0">è·å¾—ç»“æœ</h6>
            </div>
        </div>

        <!-- ä¸»å·¥ä½œåŒº -->
        <div class="row">
            <div class="col-lg-8">
                <!-- æ–‡æœ¬è¾“å…¥åŒº -->
                <div class="step-card active">
                    <div class="step-header">
                        <div class="step-icon">
                            <i class="bi bi-chat-square-text"></i>
                        </div>
                        <div>
                            <h3 class="step-title">1. è¾“å…¥è¦åˆæˆçš„æ–‡æœ¬</h3>
                            <p class="step-subtitle">è¾“å…¥æ‚¨æƒ³è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬å†…å®¹</p>
                        </div>
                    </div>

                    <div class="mb-4">
                        <textarea class="form-control" id="tts-text" rows="5" placeholder="è¯·è¾“å…¥è¦è½¬æ¢ä¸ºè¯­éŸ³çš„æ–‡æœ¬..."></textarea>
                        <div class="mt-2">
                            <button class="btn btn-sm btn-outline-primary example-btn" data-text="æ¬¢è¿ä½¿ç”¨æ™ºèƒ½è¯­éŸ³åˆæˆç³»ç»Ÿï¼Œè¿™æ˜¯ä¸€é”®ç”Ÿæˆå…‹éš†è¯­éŸ³çš„å®Œæ•´è§£å†³æ–¹æ¡ˆã€‚ç³»ç»Ÿæ”¯æŒæµå¼å¤„ç†é•¿éŸ³é¢‘ï¼Œå®æ—¶æ˜¾ç¤ºæ¯ä¸ªç‰‡æ®µçš„å¤„ç†è¿›åº¦ã€‚">
                                <i class="bi bi-card-text"></i> ç¤ºä¾‹1
                            </button>
                            <button class="btn btn-sm btn-outline-primary example-btn" data-text="Hello, this is an English example text for testing the voice cloning system with one-click generation. The system supports streaming processing for long audio and shows real-time progress for each segment.">
                                <i class="bi bi-card-text"></i> ç¤ºä¾‹2
                            </button>
                            <button class="btn btn-sm btn-outline-primary example-btn" data-text="äººå·¥æ™ºèƒ½æŠ€æœ¯æ­£åœ¨å¿«é€Ÿå‘å±•ï¼Œè¯­éŸ³åˆæˆå’ŒéŸ³è‰²å…‹éš†æŠ€æœ¯è®©æˆ‘ä»¬èƒ½å¤Ÿåˆ›é€ æ›´åŠ è‡ªç„¶å’Œä¸ªæ€§åŒ–çš„è¯­éŸ³ä½“éªŒã€‚è¿™é¡¹æŠ€æœ¯å¯ä»¥åº”ç”¨äºæœ‰å£°è¯»ç‰©ã€è™šæ‹ŸåŠ©æ‰‹ã€è§†é¢‘é…éŸ³ç­‰å¤šä¸ªé¢†åŸŸï¼Œä¸ºç”¨æˆ·æä¾›æ›´åŠ ä¸°å¯Œçš„å¬è§‰ä½“éªŒã€‚é€šè¿‡æµå¼å¤„ç†æŠ€æœ¯ï¼Œæˆ‘ä»¬å¯ä»¥å¤„ç†ä»»æ„é•¿åº¦çš„éŸ³é¢‘æ–‡ä»¶ï¼ŒåŒæ—¶å®æ—¶æ˜¾ç¤ºå¤„ç†è¿›åº¦ï¼Œè®©ç”¨æˆ·æ¸…æ™°äº†è§£å½“å‰çŠ¶æ€ã€‚">
                                <i class="bi bi-card-text"></i> é•¿æ–‡æœ¬ç¤ºä¾‹
                            </button>
                        </div>
                    </div>
                </div>

                <!-- éŸ³è‰²ä¸Šä¼ åŒº -->
                <div class="step-card">
                    <div class="step-header">
                        <div class="step-icon">
                            <i class="bi bi-mic"></i>
                        </div>
                        <div>
                            <h3 class="step-title">2. ä¸Šä¼ ç›®æ ‡éŸ³è‰²</h3>
                            <p class="step-subtitle">ä¸Šä¼ æ‚¨æƒ³è¦æ¨¡ä»¿çš„å£°éŸ³ï¼ˆå»ºè®®2-10ç§’æ¸…æ™°éŸ³é¢‘ï¼‰</p>
                        </div>
                    </div>

                    <div class="upload-box" id="target-drop-zone">
                        <div class="upload-icon">
                            <i class="bi bi-upload"></i>
                        </div>
                        <h5>ç‚¹å‡»ä¸Šä¼ æˆ–æ‹–æ‹½éŸ³é¢‘æ–‡ä»¶</h5>
                        <p class="text-muted mb-0">æ”¯æŒ WAV, MP3, FLAC, OGG æ ¼å¼ï¼Œå»ºè®®æ–‡ä»¶å°äº10MB</p>
                        <input type="file" id="target-audio-file" accept="audio/*" style="display: none;">
                    </div>

                    <div id="target-audio-info" style="display: none;">
                        <div class="audio-preview">
                            <h6 class="mb-2">ç›®æ ‡éŸ³è‰²é¢„è§ˆ:</h6>
                            <audio id="target-audio-player" controls playsinline></audio>
                            <div class="file-info">
                                <p class="mb-1"><strong>æ–‡ä»¶:</strong> <span id="target-file-name"></span></p>
                                <p class="mb-0"><strong>å¤§å°:</strong> <span id="target-file-size"></span></p>
                            </div>
                        </div>
                    </div>

                    <div class="file-status pending" id="file-status-target">
                        <div class="file-status-icon">
                            <i class="bi bi-hourglass"></i>
                        </div>
                        <div>
                            <strong>ç›®æ ‡éŸ³è‰²</strong>
                            <p class="mb-0 text-muted">ç­‰å¾…ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶</p>
                        </div>
                    </div>
                </div>

                <!-- å‚æ•°è®¾ç½®åŒº -->
                <div class="step-card">
                    <div class="step-header">
                        <div class="step-icon">
                            <i class="bi bi-gear"></i>
                        </div>
                        <div>
                            <h3 class="step-title">3. è®¾ç½®åˆæˆå‚æ•°</h3>
                            <p class="step-subtitle">è°ƒæ•´è¯­éŸ³å‚æ•°ä»¥è·å¾—æœ€ä½³æ•ˆæœ</p>
                        </div>
                    </div>

                    <div class="quick-settings">
                        <div class="quick-setting-item">
                            <label class="form-label fw-bold">è¯­éŸ³æ¨¡å‹</label>
                            <select class="form-select" id="tts-model">
                                <option value="zh_CN-huayan-medium">ä¸­æ–‡-èŠ±æ ·</option>
                                <option value="en_US-lessac-low">è‹±è¯­-Lessac</option>
                            </select>
                        </div>
                        <div class="quick-setting-item">
                            <label class="form-label fw-bold">è¯­é€Ÿ <span class="param-value" id="tts-speed-value">1.0</span></label>
                            <input type="range" class="control-slider" id="tts-speed" min="0.5" max="2.0" step="0.1" value="1.0">
                        </div>
                        <div class="quick-setting-item">
                            <label class="form-label fw-bold">éŸ³è‰²å¼ºåº¦ <span class="param-value" id="tau-value">0.3</span></label>
                            <input type="range" class="control-slider" id="tau-slider" min="0" max="1" step="0.1" value="0.3">
                        </div>
                    </div>

                    <div class="settings-panel">
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="enable-streaming" checked>
                            <label class="form-check-label" for="enable-streaming">
                                <strong>æ™ºèƒ½æµå¼å¤„ç†</strong> (è‡ªåŠ¨å¤„ç†é•¿éŸ³é¢‘)
                            </label>
                        </div>
                        <div class="advanced-options" id="advanced-options" style="display: none;">
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <label class="form-label fw-bold">ç‰‡æ®µæ—¶é•¿(ç§’)</label>
                                    <input type="number" class="form-control" id="segment-duration" min="5" max="30" value="10">
                                </div>
                                <div class="col-md-6">
                                    <label class="form-label fw-bold">å¹¶å‘å¤„ç†æ•°</label>
                                    <select class="form-select" id="concurrent-count">
                                        <option value="2">2</option>
                                        <option value="3" selected>3</option>
                                        <option value="5">5</option>
                                    </select>
                                </div>
                            </div>
                        </div>
                        <div class="text-end mt-2">
                            <span class="toggle-advanced" id="toggle-advanced">
                                <i class="bi bi-gear"></i> é«˜çº§é€‰é¡¹
                            </span>
                        </div>
                    </div>

                    <div class="alert alert-info mt-3">
                        <small>
                            <i class="bi bi-info-circle"></i>
                            <strong>å‚æ•°è¯´æ˜:</strong>
                            <ul class="mb-0 mt-2">
                                <li><strong>éŸ³è‰²å¼ºåº¦:</strong> æ§åˆ¶ç›®æ ‡éŸ³è‰²çš„å½±å“ç¨‹åº¦ï¼ˆ0.3-0.5ä¸ºæ¨èå€¼ï¼‰</li>
                                <li><strong>æ™ºèƒ½æµå¼å¤„ç†:</strong> é•¿æ–‡æœ¬è‡ªåŠ¨åˆ‡åˆ†å¤„ç†ï¼Œå®æ—¶æ˜¾ç¤ºå¤„ç†è¿›åº¦</li>
                                <li><strong>å¹¶å‘å¤„ç†:</strong> åŒæ—¶å¤„ç†å¤šä¸ªéŸ³é¢‘ç‰‡æ®µï¼Œæé«˜å¤„ç†é€Ÿåº¦</li>
                            </ul>
                        </small>
                    </div>
                </div>

                <!-- ä¸€é”®ç”ŸæˆåŒº -->
                <div class="one-click-section">
                    <button class="action-button btn-generate" id="generate-all-btn" disabled>
                        <i class="bi bi-magic"></i> ä¸€é”®ç”Ÿæˆå…‹éš†è¯­éŸ³
                    </button>
                    <p class="text-muted mt-2">ç‚¹å‡»æŒ‰é’®ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨å®Œæˆï¼šTTSç”Ÿæˆ â†’ éŸ³è‰²å…‹éš† â†’ è¾“å‡ºç»“æœ</p>
                </div>

                <!-- å¤„ç†è¿›åº¦ -->
                <div class="progress-container" id="progress-container" style="display: none;">
                    <h5 class="mb-3"><i class="bi bi-lightning-charge"></i> æ•´ä½“å¤„ç†è¿›åº¦</h5>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="progress-bar" style="width: 0%">
                            0%
                        </div>
                    </div>
                    <div class="text-center mt-2" id="progress-info">
                        å‡†å¤‡å¼€å§‹å¤„ç†...
                    </div>

                    <div class="processing-steps mt-4">
                        <div class="processing-step" id="step-tts">
                            <div class="step-check">1</div>
                            <div>
                                <strong>ç”ŸæˆTTSè¯­éŸ³</strong>
                                <p class="mb-0 text-muted" id="step-tts-detail">å°†æ–‡æœ¬è½¬æ¢ä¸ºè¯­éŸ³</p>
                            </div>
                        </div>
                        <div class="processing-step" id="step-clone">
                            <div class="step-check">2</div>
                            <div>
                                <strong>éŸ³è‰²å…‹éš†å¤„ç†</strong>
                                <p class="mb-0 text-muted" id="step-clone-detail">å°†TTSè¯­éŸ³å…‹éš†ä¸ºç›®æ ‡éŸ³è‰²</p>
                            </div>
                        </div>
                        <div class="processing-step" id="step-merge">
                            <div class="step-check">3</div>
                            <div>
                                <strong>åˆå¹¶ä¸ä¼˜åŒ–</strong>
                                <p class="mb-0 text-muted" id="step-merge-detail">å¤„ç†å¹¶ä¼˜åŒ–æœ€ç»ˆéŸ³é¢‘</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- æµå¼å¤„ç†ä¿¡æ¯ -->
                <div class="streaming-info" id="streaming-info">
                    <h6><i class="bi bi-list-ul"></i> æµå¼å¤„ç†è¿›åº¦</h6>
                    <div class="streaming-stats" id="streaming-stats">
                        <div class="stat-card">
                            <div class="stat-value" id="total-segments">0</div>
                            <div class="stat-label">æ€»ç‰‡æ®µæ•°</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="processed-segments">0</div>
                            <div class="stat-label">å·²å¤„ç†</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="processing-speed">0/s</div>
                            <div class="stat-label">å¤„ç†é€Ÿåº¦</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-value" id="success-rate">0%</div>
                            <div class="stat-label">æˆåŠŸç‡</div>
                        </div>
                    </div>
                    <div class="segment-list" id="segment-list">
                        <!-- ç‰‡æ®µåˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                    </div>
                </div>
            </div>

            <div class="col-lg-4">
                <!-- çŠ¶æ€é¢æ¿ -->
                <div class="card border-0 shadow-sm h-100">
                    <div class="card-header bg-white border-0 pb-0">
                        <h5 class="mb-0"><i class="bi bi-speedometer2"></i> ç³»ç»ŸçŠ¶æ€</h5>
                    </div>
                    <div class="card-body">
                        <div id="status-container">
                            <div class="alert alert-info">
                                <i class="bi bi-info-circle"></i> å‡†å¤‡å¼€å§‹è¯­éŸ³åˆæˆ...
                            </div>
                        </div>

                        <!-- æ–‡ä»¶çŠ¶æ€ -->
                        <div class="mt-3">
                            <h6><i class="bi bi-files"></i> æ–‡ä»¶å‡†å¤‡çŠ¶æ€</h6>
                            <div class="file-status pending" id="status-text">
                                <div class="file-status-icon">
                                    <i class="bi bi-hourglass"></i>
                                </div>
                                <div>
                                    <strong>æ–‡æœ¬å†…å®¹</strong>
                                    <p class="mb-0 text-muted">ç­‰å¾…è¾“å…¥</p>
                                </div>
                            </div>
                            <div class="file-status pending" id="status-voice">
                                <div class="file-status-icon">
                                    <i class="bi bi-hourglass"></i>
                                </div>
                                <div>
                                    <strong>ç›®æ ‡éŸ³è‰²</strong>
                                    <p class="mb-0 text-muted">ç­‰å¾…ä¸Šä¼ </p>
                                </div>
                            </div>
                        </div>

                        <!-- å®æ—¶ç»Ÿè®¡ -->
                        <div class="mt-3" id="real-time-stats" style="display: none;">
                            <h6><i class="bi bi-graph-up"></i> å®æ—¶ç»Ÿè®¡</h6>
                            <ul class="list-unstyled">
                                <li><i class="bi bi-clock text-primary"></i> å·²ç”¨æ—¶é—´: <span id="elapsed-time">0ç§’</span></li>
                                <li><i class="bi bi-cpu text-primary"></i> æ€»ä½“è¿›åº¦: <span id="overall-progress">0%</span></li>
                                <li><i class="bi bi-database text-primary"></i> é¢„ä¼°å‰©ä½™: <span id="estimated-remaining">-</span></li>
                            </ul>
                        </div>

                        <!-- ç»“æœ -->
                        <div id="result-container" style="display: none;">
                            <div class="result-card">
                                <div class="result-header">
                                    <i class="bi bi-check-circle-fill"></i>
                                    <h5 class="mb-0">ğŸ‰ å¤„ç†å®Œæˆ!</h5>
                                </div>
                                <div class="audio-preview">
                                    <h6 class="mb-2">æœ€ç»ˆå…‹éš†è¯­éŸ³:</h6>
                                    <audio id="final-result-audio" controls playsinline></audio>
                                </div>
                                <div class="mt-3">
                                    <button class="action-button btn-download w-100" id="final-download-btn">
                                        <i class="bi bi-download"></i> ä¸‹è½½å…‹éš†è¯­éŸ³ (WAVæ ¼å¼)
                                    </button>
                                </div>
                                <div class="mt-3">
                                    <h6><i class="bi bi-graph-up"></i> å¤„ç†ç»Ÿè®¡:</h6>
                                    <ul class="list-unstyled" id="stats-list">
                                        <li><i class="bi bi-clock text-primary"></i> TTSç”Ÿæˆ: <span class="text-success" id="tts-time">-</span></li>
                                        <li><i class="bi bi-clock text-primary"></i> éŸ³è‰²å…‹éš†: <span class="text-success" id="clone-time">-</span></li>
                                        <li><i class="bi bi-pie-chart text-primary"></i> ç‰‡æ®µæ•°: <span class="text-success" id="segment-count">-</span></li>
                                        <li><i class="bi bi-clock text-primary"></i> æ€»è€—æ—¶: <span class="text-success" id="total-time">-</span></li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <!-- å†å²è®°å½• -->
                        <div class="mt-4">
                            <h6><i class="bi bi-clock-history"></i> æ“ä½œè®°å½•</h6>
                            <div class="list-group list-group-flush" id="history-list">
                                <div class="list-group-item d-flex justify-content-between align-items-center">
                                    <span>ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ</span>
                                    <small class="text-muted">åˆšåˆš</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- WASM éŸ³é¢‘å¤„ç†å™¨æ¨¡å— (åªä½¿ç”¨ Emscripten ç”Ÿæˆçš„æ–‡ä»¶) -->
    <script>
        // å…¨å±€ WASM é…ç½® - Emscripten è„šæœ¬ä¼šæŸ¥æ‰¾è¿™ä¸ª
        window.WASM_BINARY_URL = 'audio_processor.wasm';
        
        // é¢„åŠ è½½ WASM æ–‡ä»¶ï¼ˆåœ¨è„šæœ¬åŠ è½½å‰ï¼‰
        window.wasmLoadPromise = (async function preloadWasm() {
            try {
                console.log('[WASM é¢„åŠ è½½] å¼€å§‹...');
                const response = await fetch('audio_processor.wasm');
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ' ' + response.statusText);
                }
                window._wasmBinary = await response.arrayBuffer();
                console.log('[WASM é¢„åŠ è½½] âœ“ å®Œæˆï¼Œå¤§å°:', window._wasmBinary.byteLength, 'bytes');
                return true;
            } catch (error) {
                console.error('[WASM é¢„åŠ è½½] âœ— å¤±è´¥:', error.message);
                return false;
            }
        })();
    </script>
    <script src="audio_processor.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // æœåŠ¡åœ°å€
        const TTS_SERVER = 'https://lglfr-tts.hf.space';
        const ISV_SERVER = 'https://lglfr-ivc.hf.space';

        // WASM éŸ³é¢‘å¤„ç†å™¨åŒ…è£…å™¨
        let audioProcessor = null;
        let wasmModule = null;

        // åˆå§‹åŒ– WASM æ¨¡å—
        async function initWASMAudioProcessor() {
            try {
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('å¼€å§‹åˆå§‹åŒ– WASM éŸ³é¢‘å¤„ç†æ¨¡å—');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');

                // ç­‰å¾… WASM é¢„åŠ è½½å®Œæˆ
                console.log('ç­‰å¾… WASM é¢„åŠ è½½...');
                if (window.wasmLoadPromise) {
                    await window.wasmLoadPromise;
                    console.log('âœ“ WASM é¢„åŠ è½½å·²å®Œæˆ');
                }

                // æ£€æŸ¥ AudioProcessorWASM æ˜¯å¦å­˜åœ¨
                if (typeof AudioProcessorWASM === 'undefined') {
                    throw new Error('AudioProcessorWASM æ¨¡å—æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥ audio_processor.js æ–‡ä»¶');
                }
                console.log('âœ“ AudioProcessorWASM å…¨å±€å˜é‡å·²å®šä¹‰');

                // è°ƒç”¨ AudioProcessorWASM - Emscripten è¿”å› Promise
                console.log('è°ƒç”¨ AudioProcessorWASM({})...');
                let module = null;
                
                try {
                    // ä¼ é€’é¢„åŠ è½½çš„ WASM äºŒè¿›åˆ¶
                    const config = {
                        wasmBinary: window._wasmBinary || undefined,
                        locateFile: function(filename) {
                            if (filename === 'audio_processor.wasm') {
                                return 'audio_processor.wasm';
                            }
                            return filename;
                        },
                        noExitRuntime: true,
                        onRuntimeInitialized: function() {
                            console.log('[Emscripten] onRuntimeInitialized å›è°ƒè§¦å‘');
                        }
                    };
                    
                    console.log('WASM äºŒè¿›åˆ¶å·²é¢„åŠ è½½:', !!window._wasmBinary, window._wasmBinary ? '(' + window._wasmBinary.byteLength + 'B)' : '');
                    const result = AudioProcessorWASM(config);
                    console.log('è¿”å›å€¼ç±»å‹:', typeof result);
                    console.log('æ˜¯å¦ä¸º Promise:', result instanceof Promise);
                    
                    // æ˜¾å¼å¤„ç† Promise
                    if (result && typeof result.then === 'function') {
                        console.log('ç­‰å¾… Promise å®Œæˆï¼ˆè¶…æ—¶: 20ç§’ï¼‰...');
                        module = await Promise.race([
                            result,
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Promise è¶…æ—¶ (20s)')), 20000)
                            )
                        ]);
                        console.log('âœ“ Promise å·²è§£å†³');
                        console.log('  è¿”å›å€¼ç±»å‹:', typeof module);
                    } else if (result) {
                        // ç›´æ¥æ˜¯å¯¹è±¡
                        module = result;
                        console.log('ç›´æ¥è¿”å›æ¨¡å—å¯¹è±¡');
                    } else {
                        throw new Error('AudioProcessorWASM è¿”å›å€¼ä¸º ' + String(result));
                    }
                } catch (initErr) {
                    console.error('âœ— AudioProcessorWASM è°ƒç”¨å¼‚å¸¸:');
                    console.error('  æ¶ˆæ¯:', initErr.message || String(initErr));
                    console.error('  ç±»å‹:', initErr.name || initErr.constructor.name);
                    throw initErr;
                }

                if (!module || typeof module !== 'object') {
                    throw new Error('WASM æ¨¡å—åˆå§‹åŒ–å¤±è´¥ï¼šè¿”å›å€¼æ— æ•ˆ (' + typeof module + ')');
                }
                console.log('âœ“ WASM æ¨¡å—å¯¹è±¡æœ‰æ•ˆ');

                // è®°å½•æ¨¡å—å±æ€§
                const allKeys = Object.keys(module);
                console.log('æ¨¡å—å±æ€§æ€»æ•°:', allKeys.length);
                console.log('æ¨¡å—å±æ€§(å‰30ä¸ª):', allKeys.slice(0, 30));

                // åˆå§‹åŒ– WASM å†…å­˜
                if (typeof module._wasm_init_memory === 'function') {
                    console.log('åˆå§‹åŒ– WASM å†…å­˜...');
                    module._wasm_init_memory();
                    console.log('âœ“ WASM å†…å­˜åˆå§‹åŒ–å®Œæˆ');
                } else {
                    console.warn('âš  æœªæ‰¾åˆ° _wasm_init_memory å‡½æ•°');
                }

                // åˆ›å»º WASM éŸ³é¢‘å¤„ç†å™¨åŒ…è£…å™¨
                wasmModule = module;
                audioProcessor = {
                    initialized: true,
                    _module: module,
                    
                    // éŸ³é¢‘è½¬ WAV æ ¼å¼
                    audioBufferToWav: function(audioBuffer, bitsPerSample = 16) {
                        console.log('âœ“ WASM: éŸ³é¢‘è½¬ WAV (é‡‡æ ·ç‡=' + audioBuffer.sampleRate + ', é•¿åº¦=' + audioBuffer.length + ')');
                        try {
                            return wasmAudioBufferToWav(audioBuffer, bitsPerSample);
                        } catch (error) {
                            console.warn('WASM è½¬æ¢å¤±è´¥ï¼Œä½¿ç”¨ JS å®ç°:', error.message);
                            return audioBufferToWavLegacy(audioBuffer);
                        }
                    },
                    
                    // éŸ³é¢‘åˆ‡åˆ† - æµå¼å¤„ç†æ ¸å¿ƒå‡½æ•°
                    splitAudioIntoSegments: async function(audioBuffer, segmentDuration, audioContext) {
                        console.log('âœ“ WASM: éŸ³é¢‘åˆ‡åˆ† (æ—¶é•¿=' + segmentDuration + 's)');
                        try {
                            return await wasmSplitAudioIntoSegments(audioBuffer, segmentDuration);
                        } catch (error) {
                            console.warn('WASM åˆ‡åˆ†å¤±è´¥ï¼Œä½¿ç”¨ JS å®ç°:', error.message);
                            const audioBlob = audioBufferToWavLegacy(audioBuffer);
                            return splitAudioIntoSegmentsLegacy(audioBlob, segmentDuration);
                        }
                    },
                    
                    // éŸ³é¢‘æ®µåˆå¹¶
                    mergeAudioSegments: async function(wavBlobs, audioContext) {
                        console.log('âœ“ WASM: éŸ³é¢‘åˆå¹¶ (' + wavBlobs.length + ' æ®µ)');
                        try {
                            // ä½¿ç”¨ JavaScript å®ç°åˆå¹¶ï¼Œä½†åœ¨è¿™ä¸ªä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œ
                            const ctx = audioContext || getAudioContext();
                            const audioBuffers = [];
                            
                            // è§£ç æ‰€æœ‰ Blob ä¸º AudioBuffer
                            for (let i = 0; i < wavBlobs.length; i++) {
                                const arrayBuffer = await wavBlobs[i].arrayBuffer();
                                const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
                                audioBuffers.push(audioBuffer);
                            }
                            
                            // è®¡ç®—æ€»é•¿åº¦
                            const totalLength = audioBuffers.reduce((sum, buf) => sum + buf.length, 0);
                            const mergedBuffer = ctx.createBuffer(
                                audioBuffers[0].numberOfChannels,
                                totalLength,
                                audioBuffers[0].sampleRate
                            );
                            
                            // åˆå¹¶æ•°æ®
                            let offset = 0;
                            for (const buffer of audioBuffers) {
                                for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
                                    const sourceData = buffer.getChannelData(ch);
                                    const targetData = mergedBuffer.getChannelData(ch);
                                    targetData.set(sourceData, offset);
                                }
                                offset += buffer.length;
                            }
                            
                            // è½¬æ¢ä¸º WAV Blob
                            const wavBlob = audioBufferToWavLegacy(mergedBuffer);
                            return wavBlob;
                        } catch (error) {
                            console.warn('WASM åˆå¹¶å¤±è´¥:', error.message);
                            throw error;
                        }
                    }
                };

                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('âœ“ WASM æ¨¡å—åˆå§‹åŒ–æˆåŠŸ');
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            } catch (error) {
                console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.error('âœ— WASM åˆå§‹åŒ–å¤±è´¥');
                console.error('é”™è¯¯ç±»å‹:', error ? error.constructor.name : 'Unknown');
                console.error('é”™è¯¯ä¿¡æ¯:', error ? error.message : String(error));
                if (error && error.stack) {
                    console.error('å®Œæ•´å †æ ˆ:', error.stack);
                }
                console.error('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.warn('å°†ä½¿ç”¨ JavaScript å®ç°æ‰€æœ‰éŸ³é¢‘å¤„ç†åŠŸèƒ½');
                audioProcessor = null;
                wasmModule = null;
            }
        }

        // WASM éŸ³é¢‘å¤„ç†è¾…åŠ©å‡½æ•°
        function wasmAudioBufferToWav(audioBuffer, bitsPerSample = 16) {
            // ä½¿ç”¨ JavaScript å®ç°è½¬æ¢ä¸º WAV
            return audioBufferToWavLegacy(audioBuffer);
        }

        // WASM éŸ³é¢‘åˆ‡åˆ†å‡½æ•° - æµå¼å¤„ç†çš„å…³é”®
        async function wasmSplitAudioIntoSegments(audioBuffer, segmentDuration) {
            const sampleRate = audioBuffer.sampleRate;
            const samplesPerSegment = segmentDuration * sampleRate;
            const totalSamples = audioBuffer.length;
            const numSegments = Math.ceil(totalSamples / samplesPerSegment);
            
            console.log(`WASM åˆ‡åˆ†å‚æ•°: é‡‡æ ·ç‡=${sampleRate}, æ€»æ ·æœ¬=${totalSamples}, åˆ†æ®µæ•°=${numSegments}`);
            
            const segments = [];
            for (let i = 0; i < numSegments; i++) {
                const startSample = i * samplesPerSegment;
                const endSample = Math.min(startSample + samplesPerSegment, totalSamples);
                
                // åˆ›å»ºå­ AudioBuffer
                const segmentBuffer = getAudioContext().createBuffer(
                    audioBuffer.numberOfChannels,
                    endSample - startSample,
                    sampleRate
                );
                
                for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
                    const sourceData = audioBuffer.getChannelData(ch);
                    const targetData = segmentBuffer.getChannelData(ch);
                    targetData.set(sourceData.subarray(startSample, endSample));
                }
                
                // è½¬æ¢ä¸º WAV Blob ç„¶åè½¬ä¸º base64
                const wavBlob = audioBufferToWavLegacy(segmentBuffer);
                const base64 = await blobToBase64(wavBlob);
                segments.push({
                    index: i,
                    base64: base64,
                    duration: (endSample - startSample) / sampleRate,
                    startTime: startSample / sampleRate,
                    endTime: endSample / sampleRate
                });
            }
            
            console.log(`WASM åˆ‡åˆ†å®Œæˆ: ç”Ÿæˆ ${segments.length} ä¸ªéŸ³é¢‘æ®µ`);
            return {
                segments: segments,
                totalDuration: totalSamples / sampleRate,
                sampleRate: sampleRate,
                numSegments: numSegments
            };
        }

        // WASM éŸ³é¢‘åˆå¹¶å‡½æ•°
        // WASM éŸ³é¢‘åˆå¹¶ä¼˜åŒ– - ä½¿ç”¨å†…å­˜é«˜æ•ˆçš„æ–¹å¼
        async function wasmMergeAudioSegments(wavBlobs, audioContext) {
            console.log(`[WASM åˆå¹¶] å¼€å§‹åˆå¹¶ ${wavBlobs.length} ä¸ªéŸ³é¢‘æ®µ`);
            
            const audioBuffers = [];
            const ctx = audioContext || getAudioContext();
            
            // é˜¶æ®µ 1: è§£ç æ‰€æœ‰ç‰‡æ®µ
            for (let i = 0; i < wavBlobs.length; i++) {
                try {
                    const arrayBuffer = await wavBlobs[i].arrayBuffer();
                    const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
                    audioBuffers.push(audioBuffer);
                    console.log(`[WASM åˆå¹¶] ç‰‡æ®µ ${i}: ${audioBuffer.length} samples @ ${audioBuffer.sampleRate}Hz, ${audioBuffer.numberOfChannels} é€šé“`);
                } catch (error) {
                    console.error(`[WASM åˆå¹¶] è§£ç ç‰‡æ®µ ${i} å¤±è´¥:`, error);
                    throw error;
                }
            }
            
            // é˜¶æ®µ 2: è®¡ç®—åˆå¹¶å‚æ•°
            const totalLength = audioBuffers.reduce((sum, buf) => sum + buf.length, 0);
            const channels = audioBuffers[0].numberOfChannels;
            const sampleRate = audioBuffers[0].sampleRate;
            
            console.log(`[WASM åˆå¹¶] æ€»é•¿åº¦: ${totalLength} samples, é€šé“: ${channels}, é‡‡æ ·ç‡: ${sampleRate}Hz`);
            
            // é˜¶æ®µ 3: åˆ›å»ºåˆå¹¶åçš„ buffer
            const mergedBuffer = ctx.createBuffer(channels, totalLength, sampleRate);
            
            // é˜¶æ®µ 4: é€é€šé“åˆå¹¶æ•°æ®
            for (let ch = 0; ch < channels; ch++) {
                const targetData = mergedBuffer.getChannelData(ch);
                let offset = 0;
                
                for (const buffer of audioBuffers) {
                    const sourceData = buffer.getChannelData(ch);
                    targetData.set(sourceData, offset);
                    offset += buffer.length;
                }
            }
            
            // é˜¶æ®µ 5: è½¬æ¢ä¸º WAV
            const wavBlob = audioBufferToWavLegacy(mergedBuffer);
            console.log(`[WASM åˆå¹¶] å®Œæˆï¼ŒWAV å¤§å°: ${wavBlob.size} bytes`);
            return wavBlob;
        }

        // çŠ¶æ€å˜é‡
        let ttsAudioBlob = null;
        let targetAudioBlob = null;
        let clonedAudioBase64 = null;
        let clonedAudioBlob = null;
        let audioContext = null;
        let processingStartTime = null;
        let ttsStartTime = 0;
        let cloneStartTime = 0;
        let totalProcessingTime = 0;
        let streamingStats = {
            totalSegments: 0,
            processedSegments: 0,
            successfulSegments: 0,
            failedSegments: 0,
            startTime: null,
            segments: []
        };

        // DOMå…ƒç´ 
        const elements = {
            // æœåŠ¡çŠ¶æ€
            ttsServiceStatus: document.getElementById('tts-service-status'),
            isvServiceStatus: document.getElementById('isv-service-status'),
            
            // å·¥ä½œæµå›¾ç¤º
            step1Wf: document.getElementById('step1-wf'),
            step2Wf: document.getElementById('step2-wf'),
            step3Wf: document.getElementById('step3-wf'),
            step4Wf: document.getElementById('step4-wf'),
            step5Wf: document.getElementById('step5-wf'),
            
            // æ–‡æœ¬è¾“å…¥
            ttsText: document.getElementById('tts-text'),
            
            // å‚æ•°è®¾ç½®
            ttsModel: document.getElementById('tts-model'),
            ttsSpeed: document.getElementById('tts-speed'),
            ttsSpeedValue: document.getElementById('tts-speed-value'),
            tauSlider: document.getElementById('tau-slider'),
            tauValue: document.getElementById('tau-value'),
            
            // æµå¼è®¾ç½®
            enableStreaming: document.getElementById('enable-streaming'),
            segmentDuration: document.getElementById('segment-duration'),
            concurrentCount: document.getElementById('concurrent-count'),
            toggleAdvanced: document.getElementById('toggle-advanced'),
            advancedOptions: document.getElementById('advanced-options'),
            
            // æ–‡ä»¶ä¸Šä¼ 
            targetDropZone: document.getElementById('target-drop-zone'),
            targetAudioFile: document.getElementById('target-audio-file'),
            targetAudioInfo: document.getElementById('target-audio-info'),
            targetAudioPlayer: document.getElementById('target-audio-player'),
            targetFileName: document.getElementById('target-file-name'),
            targetFileSize: document.getElementById('target-file-size'),
            fileStatusTarget: document.getElementById('file-status-target'),
            
            // çŠ¶æ€æ˜¾ç¤º
            statusText: document.getElementById('status-text'),
            statusVoice: document.getElementById('status-voice'),
            
            // ç”ŸæˆæŒ‰é’®
            generateAllBtn: document.getElementById('generate-all-btn'),
            
            // è¿›åº¦æ˜¾ç¤º
            progressContainer: document.getElementById('progress-container'),
            progressBar: document.getElementById('progress-bar'),
            progressInfo: document.getElementById('progress-info'),
            
            // å¤„ç†æ­¥éª¤
            stepTts: document.getElementById('step-tts'),
            stepClone: document.getElementById('step-clone'),
            stepMerge: document.getElementById('step-merge'),
            stepTtsDetail: document.getElementById('step-tts-detail'),
            stepCloneDetail: document.getElementById('step-clone-detail'),
            stepMergeDetail: document.getElementById('step-merge-detail'),
            
            // æµå¼å¤„ç†ä¿¡æ¯
            streamingInfo: document.getElementById('streaming-info'),
            totalSegments: document.getElementById('total-segments'),
            processedSegments: document.getElementById('processed-segments'),
            processingSpeed: document.getElementById('processing-speed'),
            successRate: document.getElementById('success-rate'),
            segmentList: document.getElementById('segment-list'),
            
            // çŠ¶æ€é¢æ¿
            statusContainer: document.getElementById('status-container'),
            resultContainer: document.getElementById('result-container'),
            finalResultAudio: document.getElementById('final-result-audio'),
            finalDownloadBtn: document.getElementById('final-download-btn'),
            ttsTime: document.getElementById('tts-time'),
            cloneTime: document.getElementById('clone-time'),
            segmentCount: document.getElementById('segment-count'),
            totalTime: document.getElementById('total-time'),
            realTimeStats: document.getElementById('real-time-stats'),
            elapsedTime: document.getElementById('elapsed-time'),
            overallProgress: document.getElementById('overall-progress'),
            estimatedRemaining: document.getElementById('estimated-remaining'),
            historyList: document.getElementById('history-list')
        };

        // å·¥å…·å‡½æ•°ï¼šæ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // å·¥å…·å‡½æ•°ï¼šæ–‡ä»¶è½¬base64
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // å·¥å…·å‡½æ•°ï¼šBlobè½¬base64
        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(blob);
            });
        }

        // å·¥å…·å‡½æ•°ï¼šæ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type = 'info') {
            const alertClass = {
                'info': 'alert-info',
                'success': 'alert-success',
                'warning': 'alert-warning',
                'error': 'alert-danger',
                'loading': 'alert-warning'
            }[type] || 'alert-info';

            const icon = {
                'info': 'bi-info-circle',
                'success': 'bi-check-circle',
                'warning': 'bi-exclamation-triangle',
                'error': 'bi-x-circle',
                'loading': 'bi-hourglass-split'
            }[type] || 'bi-info-circle';

            elements.statusContainer.innerHTML = `
                <div class="alert ${alertClass} d-flex align-items-center">
                    <i class="bi ${icon} me-2 fs-5"></i>
                    <div>${message}</div>
                </div>
            `;
            
            // æ·»åŠ åˆ°å†å²è®°å½•
            addToHistory(message);
        }

        // å·¥å…·å‡½æ•°ï¼šæ·»åŠ åˆ°å†å²è®°å½•
        function addToHistory(message) {
            const now = new Date();
            const timeString = now.toLocaleTimeString('zh-CN', { 
                hour: '2-digit', 
                minute: '2-digit',
                second: '2-digit'
            });
            
            const historyItem = document.createElement('div');
            historyItem.className = 'list-group-item d-flex justify-content-between align-items-center';
            historyItem.innerHTML = `
                <span>${message}</span>
                <small class="text-muted">${timeString}</small>
            `;
            
            elements.historyList.insertBefore(historyItem, elements.historyList.firstChild);
            
            // é™åˆ¶å†å²è®°å½•æ•°é‡
            const items = elements.historyList.querySelectorAll('.list-group-item');
            if (items.length > 10) {
                elements.historyList.removeChild(items[items.length - 1]);
            }
        }

        // å·¥å…·å‡½æ•°ï¼šæ›´æ–°è¿›åº¦æ¡
        function updateProgress(percent, message) {
            elements.progressBar.style.width = `${percent}%`;
            elements.progressBar.textContent = `${Math.round(percent)}%`;
            elements.progressInfo.textContent = message;
            elements.overallProgress.textContent = `${Math.round(percent)}%`;
        }

        // å·¥å…·å‡½æ•°ï¼šæ˜¾ç¤ºè¿›åº¦æ¡
        function showProgress() {
            elements.progressContainer.style.display = 'block';
            elements.realTimeStats.style.display = 'block';
        }

        // å·¥å…·å‡½æ•°ï¼šéšè—è¿›åº¦æ¡
        function hideProgress() {
            setTimeout(() => {
                elements.progressContainer.style.display = 'none';
                elements.realTimeStats.style.display = 'none';
                updateProgress(0, 'å‡†å¤‡å¼€å§‹å¤„ç†...');
            }, 1000);
        }

        // å·¥å…·å‡½æ•°ï¼šæ›´æ–°å·¥ä½œæµæ­¥éª¤
        function updateWorkflowStep(step) {
            // é‡ç½®æ‰€æœ‰æ­¥éª¤
            [elements.step1Wf, elements.step2Wf, elements.step3Wf, elements.step4Wf, elements.step5Wf].forEach(el => {
                el.classList.remove('active', 'completed');
            });
            
            // æ ¹æ®æ­¥éª¤æ›´æ–°
            switch(step) {
                case 'step1':
                    elements.step1Wf.classList.add('active');
                    break;
                case 'step2':
                    elements.step1Wf.classList.add('completed');
                    elements.step2Wf.classList.add('active');
                    break;
                case 'step3':
                    elements.step1Wf.classList.add('completed');
                    elements.step2Wf.classList.add('completed');
                    elements.step3Wf.classList.add('active');
                    break;
                case 'step4':
                    elements.step1Wf.classList.add('completed');
                    elements.step2Wf.classList.add('completed');
                    elements.step3Wf.classList.add('completed');
                    elements.step4Wf.classList.add('active');
                    break;
                case 'step5':
                    [elements.step1Wf, elements.step2Wf, elements.step3Wf, elements.step4Wf, elements.step5Wf]
                        .forEach(el => el.classList.add('completed'));
                    elements.step5Wf.classList.add('active');
                    break;
            }
        }

        // å·¥å…·å‡½æ•°ï¼šæ›´æ–°å¤„ç†æ­¥éª¤çŠ¶æ€
        function updateProcessingStep(step, status, detail = '') {
            const stepElement = elements[`step${step.charAt(0).toUpperCase() + step.slice(1)}`];
            const detailElement = elements[`step${step.charAt(0).toUpperCase() + step.slice(1)}Detail`];
            
            if (stepElement) {
                stepElement.className = `processing-step ${status}`;
                const checkElement = stepElement.querySelector('.step-check');
                
                if (status === 'active') {
                    checkElement.innerHTML = '<i class="bi bi-arrow-repeat"></i>';
                } else if (status === 'completed') {
                    checkElement.innerHTML = '<i class="bi bi-check"></i>';
                } else {
                    checkElement.textContent = stepElement.querySelector('.step-check').textContent;
                }
            }
            
            if (detailElement && detail) {
                detailElement.textContent = detail;
            }
        }

        // å·¥å…·å‡½æ•°ï¼šæ£€æŸ¥æ˜¯å¦å‡†å¤‡å¥½ç”Ÿæˆ
        function checkReadyToGenerate() {
            const textReady = elements.ttsText.value.trim().length > 0;
            const voiceReady = targetAudioBlob !== null;
            
            // æ›´æ–°æ–‡ä»¶çŠ¶æ€
            if (textReady) {
                elements.statusText.className = 'file-status ready';
                elements.statusText.querySelector('.file-status-icon').innerHTML = '<i class="bi bi-check-circle"></i>';
                elements.statusText.querySelector('p').textContent = 'æ–‡æœ¬å·²å‡†å¤‡';
            } else {
                elements.statusText.className = 'file-status pending';
                elements.statusText.querySelector('.file-status-icon').innerHTML = '<i class="bi bi-hourglass"></i>';
                elements.statusText.querySelector('p').textContent = 'ç­‰å¾…è¾“å…¥';
            }
            
            if (voiceReady) {
                elements.statusVoice.className = 'file-status ready';
                elements.statusVoice.querySelector('.file-status-icon').innerHTML = '<i class="bi bi-check-circle"></i>';
                elements.statusVoice.querySelector('p').textContent = 'éŸ³è‰²å·²å‡†å¤‡';
            } else {
                elements.statusVoice.className = 'file-status pending';
                elements.statusVoice.querySelector('.file-status-icon').innerHTML = '<i class="bi bi-hourglass"></i>';
                elements.statusVoice.querySelector('p').textContent = 'ç­‰å¾…ä¸Šä¼ ';
            }
            
            // å¯ç”¨/ç¦ç”¨ç”ŸæˆæŒ‰é’®
            elements.generateAllBtn.disabled = !(textReady && voiceReady);
            
            // æ›´æ–°å·¥ä½œæµæ­¥éª¤
            if (textReady && voiceReady) {
                updateWorkflowStep('step4');
            } else if (voiceReady) {
                updateWorkflowStep('step3');
            } else if (textReady) {
                updateWorkflowStep('step2');
            }
        }

        // å·¥å…·å‡½æ•°ï¼šåˆå§‹åŒ–AudioContext
        function getAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            // ç§»åŠ¨ç«¯ä¿®å¤ï¼šæ¢å¤ suspended çŠ¶æ€çš„ AudioContext
            if (audioContext.state === 'suspended') {
                audioContext.resume().catch(err => {
                    console.warn('AudioContext resume failed:', err);
                });
            }
            return audioContext;
        }

        // ç§»åŠ¨ç«¯ AudioContext ç®¡ç†å™¨
        const MobileAudioManager = {
            initialized: false,
            resumeAttempts: 0,
            maxResumeAttempts: 5,
            
            init() {
                if (this.initialized) return;
                
                // ç›‘å¬å¤šç§ç”¨æˆ·äº¤äº’äº‹ä»¶ä»¥æ¢å¤ AudioContext
                const events = [
                    'touchstart', 'touchend', 'touchmove',
                    'click', 'mousedown', 'keydown',
                    'pointerdown', 'pointerup'
                ];
                
                const resumeHandler = async () => {
                    const ctx = getAudioContext();
                    if (ctx.state === 'suspended') {
                        try {
                            await ctx.resume();
                            console.log('[MobileAudioManager] AudioContext resumed successfully');
                            this.resumeAttempts = 0;
                        } catch (err) {
                            console.warn('[MobileAudioManager] Resume attempt failed:', err);
                            this.resumeAttempts++;
                            if (this.resumeAttempts >= this.maxResumeAttempts) {
                                console.error('[MobileAudioManager] Max resume attempts reached');
                            }
                        }
                    }
                };
                
                // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨ï¼ˆä½¿ç”¨ passive: true æé«˜æ€§èƒ½ï¼‰
                events.forEach(event => {
                    document.addEventListener(event, resumeHandler, { 
                        passive: true, 
                        once: false 
                    });
                });
                
                // é¡µé¢å¯è§æ€§å˜åŒ–æ—¶å°è¯•æ¢å¤
                document.addEventListener('visibilitychange', async () => {
                    if (!document.hidden) {
                        const ctx = getAudioContext();
                        if (ctx.state === 'suspended') {
                            try {
                                await ctx.resume();
                                console.log('[MobileAudioManager] AudioContext resumed on visibility change');
                            } catch (err) {
                                console.warn('[MobileAudioManager] Visibility change resume failed:', err);
                            }
                        }
                    }
                });
                
                this.initialized = true;
                console.log('[MobileAudioManager] Initialized');
            },
            
            async ensureResumed() {
                const ctx = getAudioContext();
                if (ctx.state === 'suspended') {
                    for (let i = 0; i < this.maxResumeAttempts; i++) {
                        try {
                            await ctx.resume();
                            console.log('[MobileAudioManager] Force resume successful');
                            return true;
                        } catch (err) {
                            console.warn(`[MobileAudioManager] Force resume attempt ${i + 1} failed:`, err);
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                    }
                    return false;
                }
                return true;
            }
        };

        // å·¥å…·å‡½æ•°ï¼šåˆ‡åˆ†éŸ³é¢‘ä¸ºç‰‡æ®µ (WASM ä¼˜åŒ–ç‰ˆ)
        async function splitAudioIntoSegments(audioBlob, segmentDuration = 10) {
            // ç¡®ä¿ AudioContext å·²æ¢å¤
            await MobileAudioManager.ensureResumed();
            
            const ctx = getAudioContext();
            const arrayBuffer = await audioBlob.arrayBuffer();
            
            // ç§»åŠ¨ç«¯éŸ³é¢‘è§£ç å¢å¼ºï¼šæ·»åŠ é‡è¯•æœºåˆ¶
            let audioBuffer;
            let decodeAttempts = 0;
            const maxDecodeAttempts = 3;
            
            while (decodeAttempts < maxDecodeAttempts) {
                try {
                    audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0)); // åˆ›å»ºå‰¯æœ¬ä»¥é¿å…æ¶ˆè€—åŸå§‹ buffer
                    break;
                } catch (error) {
                    decodeAttempts++;
                    console.warn(`[éŸ³é¢‘è§£ç ] å°è¯• ${decodeAttempts}/${maxDecodeAttempts} å¤±è´¥:`, error.message);
                    
                    if (decodeAttempts >= maxDecodeAttempts) {
                        throw new Error(`éŸ³é¢‘è§£ç å¤±è´¥ï¼Œå·²å°è¯• ${maxDecodeAttempts} æ¬¡: ${error.message}`);
                    }
                    
                    // ç­‰å¾…åé‡è¯•
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // å°è¯•æ¢å¤ AudioContext
                    await MobileAudioManager.ensureResumed();
                }
            }

            // ä¼˜å…ˆä½¿ç”¨ WASM
            if (audioProcessor && audioProcessor.initialized) {
                try {
                    console.log('ä½¿ç”¨ WASM è¿›è¡ŒéŸ³é¢‘åˆ‡åˆ†');
                    return await audioProcessor.splitAudioIntoSegments(
                        audioBuffer,
                        segmentDuration,
                        ctx
                    );
                } catch (error) {
                    console.warn('WASM éŸ³é¢‘åˆ‡åˆ†å¤±è´¥,ä½¿ç”¨ JavaScript å®ç°:', error);
                }
            }

            // å›é€€åˆ°åŸå§‹ JavaScript å®ç°
            return await splitAudioIntoSegmentsLegacy(audioBuffer, segmentDuration);
        }

        // å·¥å…·å‡½æ•°ï¼šåˆ‡åˆ†éŸ³é¢‘ä¸ºç‰‡æ®µ - è¾…åŠ©ç‰ˆæœ¬ï¼ˆè¿”å› Blob æ•°ç»„ï¼‰
        async function splitAudioIntoSegmentsLegacyBlob(audioBuffer, segmentDuration) {
            const sampleRate = audioBuffer.sampleRate;
            const samplesPerSegment = segmentDuration * sampleRate;
            const totalSamples = audioBuffer.length;
            const numSegments = Math.ceil(totalSamples / samplesPerSegment);

            const segments = [];
            for (let i = 0; i < numSegments; i++) {
                const startSample = i * samplesPerSegment;
                const endSample = Math.min((i + 1) * samplesPerSegment, totalSamples);
                const segmentBuffer = audioContext.createBuffer(
                    audioBuffer.numberOfChannels,
                    endSample - startSample,
                    sampleRate
                );

                for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                    const channelData = audioBuffer.getChannelData(channel);
                    const segmentData = segmentBuffer.getChannelData(channel);
                    for (let j = 0; j < segmentData.length; j++) {
                        segmentData[j] = channelData[startSample + j];
                    }
                }

                const wavBlob = await audioBufferToWav(segmentBuffer);
                const base64 = await blobToBase64(wavBlob);
                segments.push({
                    index: i,
                    base64: base64,
                    duration: (endSample - startSample) / sampleRate,
                    startTime: startSample / sampleRate,
                    endTime: endSample / sampleRate
                });
            }

            return {
                segments: segments,
                totalDuration: totalSamples / sampleRate,
                sampleRate: sampleRate,
                numSegments: numSegments
            };
        }

        // å·¥å…·å‡½æ•°ï¼šåˆ‡åˆ†éŸ³é¢‘ä¸ºç‰‡æ®µ (Legacy ç‰ˆæœ¬)
        async function splitAudioIntoSegmentsLegacy(audioBlob, segmentDuration = 10) {
            // ç¡®ä¿ AudioContext å·²æ¢å¤
            await MobileAudioManager.ensureResumed();
            
            const ctx = getAudioContext();
            const arrayBuffer = await audioBlob.arrayBuffer();
            
            // ç§»åŠ¨ç«¯éŸ³é¢‘è§£ç å¢å¼º
            let audioBuffer;
            let decodeAttempts = 0;
            const maxDecodeAttempts = 3;
            
            while (decodeAttempts < maxDecodeAttempts) {
                try {
                    audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));
                    break;
                } catch (error) {
                    decodeAttempts++;
                    console.warn(`[Legacyè§£ç ] å°è¯• ${decodeAttempts}/${maxDecodeAttempts} å¤±è´¥:`, error.message);
                    
                    if (decodeAttempts >= maxDecodeAttempts) {
                        throw new Error(`éŸ³é¢‘è§£ç å¤±è´¥: ${error.message}`);
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    await MobileAudioManager.ensureResumed();
                }
            }
            
            const sampleRate = audioBuffer.sampleRate;
            const samplesPerSegment = segmentDuration * sampleRate;
            const totalSamples = audioBuffer.length;
            const numSegments = Math.ceil(totalSamples / samplesPerSegment);
            
            console.log(`éŸ³é¢‘æ€»æ—¶é•¿: ${(totalSamples / sampleRate).toFixed(2)}ç§’`);
            console.log(`å°†åˆ‡åˆ†ä¸º ${numSegments} ä¸ªç‰‡æ®µï¼Œæ¯ä¸ª ${segmentDuration} ç§’`);
            
            const segments = [];
            for (let i = 0; i < numSegments; i++) {
                const startSample = i * samplesPerSegment;
                const endSample = Math.min((i + 1) * samplesPerSegment, totalSamples);
                const segmentBuffer = ctx.createBuffer(
                    audioBuffer.numberOfChannels,
                    endSample - startSample,
                    sampleRate
                );

                for (let channel = 0; channel < audioBuffer.numberOfChannels; channel++) {
                    const channelData = audioBuffer.getChannelData(channel);
                    const segmentData = segmentBuffer.getChannelData(channel);
                    for (let j = 0; j < segmentData.length; j++) {
                        segmentData[j] = channelData[startSample + j];
                    }
                }

                // å°†AudioBufferè½¬æ¢ä¸ºWAV Blob
                const wavBlob = audioBufferToWav(segmentBuffer);
                const base64 = await blobToBase64(wavBlob);
                segments.push({
                    index: i,
                    base64: base64,
                    duration: (endSample - startSample) / sampleRate,
                    startTime: startSample / sampleRate,
                    endTime: endSample / sampleRate
                });
            }

            return {
                segments: segments,
                totalDuration: totalSamples / sampleRate,
                sampleRate: sampleRate,
                numSegments: numSegments
            };
        }

        // å·¥å…·å‡½æ•°ï¼šAudioBufferè½¬WAV (WASM ä¼˜åŒ–ç‰ˆ)
        function audioBufferToWav(audioBuffer) {
            // ä¼˜å…ˆä½¿ç”¨ WASM åŒ…è£…å™¨
            if (audioProcessor && audioProcessor.initialized) {
                try {
                    return audioProcessor.audioBufferToWav(audioBuffer);
                } catch (error) {
                    console.warn('WASM WAV è½¬æ¢å¤±è´¥,ä½¿ç”¨ JavaScript å®ç°:', error);
                }
            }
            // å›é€€åˆ°åŸå§‹ JavaScript å®ç°
            return audioBufferToWavLegacy(audioBuffer);
        }

        // å·¥å…·å‡½æ•°ï¼šAudioBufferè½¬WAV (Legacy ç‰ˆæœ¬) - æ”¹è¿›ç‰ˆæœ¬
        function audioBufferToWavLegacy(audioBuffer) {
            const numberOfChannels = Math.min(2, audioBuffer.numberOfChannels);
            const sampleRate = audioBuffer.sampleRate;
            
            // è·å–æ‰€æœ‰é€šé“æ•°æ®
            const channels = [];
            for (let ch = 0; ch < numberOfChannels; ch++) {
                channels.push(audioBuffer.getChannelData(ch));
            }
            
            // è®¡ç®—æ€»æ ·æœ¬æ•°
            const length = audioBuffer.length;
            const audioData = new Float32Array(length * numberOfChannels);
            
            // äº¤é”™é€šé“æ•°æ®
            let offset = 0;
            for (let i = 0; i < length; i++) {
                for (let ch = 0; ch < numberOfChannels; ch++) {
                    audioData[offset++] = channels[ch][i];
                }
            }
            
            // è½¬æ¢ä¸º PCM
            const pcmData = new Int16Array(audioData.length);
            for (let i = 0; i < audioData.length; i++) {
                const s = Math.max(-1, Math.min(1, audioData[i]));
                pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            
            // å†™ WAV å¤´
            const wavBuffer = new ArrayBuffer(44 + pcmData.length * 2);
            const view = new DataView(wavBuffer);
            
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numberOfChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const subChunk2Size = pcmData.length * 2;
            
            // RIFF å¤´
            const writeString = (offset, string) => {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            };
            
            writeString(0, 'RIFF');
            view.setUint32(4, 36 + subChunk2Size, true);
            writeString(8, 'WAVE');
            
            // fmt å­å—
            writeString(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            
            // data å­å—
            writeString(36, 'data');
            view.setUint32(40, subChunk2Size, true);
            
            // å†™å…¥ PCM æ•°æ®
            const pcmView = new Int16Array(wavBuffer, 44);
            pcmView.set(pcmData);
            
            return new Blob([wavBuffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        // éªŒè¯å’Œä¿®å¤ WAV æ–‡ä»¶
        function validateAndFixWavData(base64) {
            let audioData;
            if (base64.includes(',')) {
                audioData = atob(base64.split(',')[1]);
            } else {
                audioData = atob(base64);
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯ WAV æ ¼å¼ï¼ˆä»¥ RIFF å¼€å¤´ï¼‰
            if (audioData.charCodeAt(0) === 0x52 && audioData.charCodeAt(1) === 0x49) { // 'RI'
                // å·²ç»æ˜¯ WAV æ ¼å¼ï¼Œç›´æ¥è¿”å›
                const arrayBuffer = new ArrayBuffer(audioData.length);
                const view = new Uint8Array(arrayBuffer);
                for (let i = 0; i < audioData.length; i++) {
                    view[i] = audioData.charCodeAt(i);
                }
                return arrayBuffer;
            }
            
            // å‡è®¾æ˜¯ PCM æ•°æ®ï¼Œéœ€è¦æ·»åŠ  WAV å¤´
            console.warn('è¾“å…¥æ•°æ®ä¸æ˜¯ WAV æ ¼å¼ï¼Œå°è¯•ä½œä¸º PCM å¤„ç†');
            
            // å‡è®¾æ˜¯ 16-bit PCM, mono, 48kHz
            const sampleRate = 48000;
            const numberOfChannels = 1;
            const bitDepth = 16;
            const bytesPerSample = bitDepth / 8;
            const blockAlign = numberOfChannels * bytesPerSample;
            
            const dataLength = audioData.length;
            const bufferLength = 44 + dataLength;
            
            const arrayBuffer = new ArrayBuffer(bufferLength);
            const view = new DataView(arrayBuffer);
            
            // å†™ WAV å¤´
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // format
            view.setUint16(22, numberOfChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * blockAlign, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitDepth, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);
            
            // å¤åˆ¶æ•°æ®
            const uint8View = new Uint8Array(arrayBuffer);
            for (let i = 0; i < audioData.length; i++) {
                uint8View[44 + i] = audioData.charCodeAt(i);
            }
            
            return arrayBuffer;
        }

        // å·¥å…·å‡½æ•°ï¼šåˆå¹¶éŸ³é¢‘ç‰‡æ®µ (WASM ä¼˜åŒ–ç‰ˆ)
        async function mergeAudioSegments(base64Segments) {
            // ç¡®ä¿ AudioContext å·²æ¢å¤
            await MobileAudioManager.ensureResumed();
            
            const ctx = getAudioContext();

            // ä¼˜å…ˆä½¿ç”¨ WASM
            if (audioProcessor && audioProcessor.initialized) {
                try {
                    console.log('[åˆå¹¶] ä½¿ç”¨ WASM è¿›è¡ŒéŸ³é¢‘åˆå¹¶');
                    console.log(`[åˆå¹¶] å¤„ç† ${base64Segments.length} ä¸ªç‰‡æ®µ`);

                    // å°† base64 è½¬æ¢ä¸º WAV blobs
                    const wavBlobs = [];
                    for (let i = 0; i < base64Segments.length; i++) {
                        const base64 = base64Segments[i];
                        if (!base64) {
                            console.error(`[åˆå¹¶] ç‰‡æ®µ ${i} ä¸ºç©º`);
                            continue;
                        }
                        
                        const arrayBuffer = validateAndFixWavData(base64);
                        wavBlobs.push(new Blob([arrayBuffer], { type: 'audio/wav' }));
                    }

                    console.log(`[åˆå¹¶] è½¬æ¢åçš„ Blobs å¤§å°:`, wavBlobs.map(b => b.size));
                    
                    // è°ƒç”¨ audioProcessor çš„åˆå¹¶æ–¹æ³•
                    const result = await audioProcessor.mergeAudioSegments(wavBlobs, ctx);
                    console.log('[åˆå¹¶] âœ“ WASM åˆå¹¶æˆåŠŸ');
                    return result;
                } catch (error) {
                    console.warn('[åˆå¹¶] WASM éŸ³é¢‘åˆå¹¶å¤±è´¥ï¼Œä½¿ç”¨ JavaScript å®ç°:', error.message);
                }
            }

            // å›é€€åˆ°åŸå§‹ JavaScript å®ç°
            return await mergeAudioSegmentsLegacy(base64Segments);
        }

        // å·¥å…·å‡½æ•°ï¼šåˆå¹¶éŸ³é¢‘ç‰‡æ®µ (Legacy ç‰ˆæœ¬)
        async function mergeAudioSegmentsLegacy(base64Segments) {
            // ç¡®ä¿ AudioContext å·²æ¢å¤
            await MobileAudioManager.ensureResumed();
            
            const ctx = getAudioContext();
            const segments = [];

            // ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šåˆ†æ‰¹è§£ç ä»¥å‡å°‘å†…å­˜å³°å€¼
            const batchSize = 5; // æ¯æ¬¡æœ€å¤šè§£ç  5 ä¸ªç‰‡æ®µ
            const maxDecodeAttempts = 3;
            
            for (let i = 0; i < base64Segments.length; i += batchSize) {
                const batch = base64Segments.slice(i, i + batchSize);
                
                for (let base64 of batch) {
                    // å¤„ç†ä¸åŒçš„base64æ ¼å¼
                    let audioData;
                    if (base64.includes(',')) {
                        audioData = atob(base64.split(',')[1]);
                    } else {
                        audioData = atob(base64);
                    }

                    const arrayBuffer = new ArrayBuffer(audioData.length);
                    const view = new Uint8Array(arrayBuffer);
                    for (let j = 0; j < audioData.length; j++) {
                        view[j] = audioData.charCodeAt(j);
                    }
                    
                    // ç§»åŠ¨ç«¯éŸ³é¢‘è§£ç å¢å¼º
                    let audioBuffer;
                    let decodeAttempts = 0;
                    
                    while (decodeAttempts < maxDecodeAttempts) {
                        try {
                            audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));
                            break;
                        } catch (error) {
                            decodeAttempts++;
                            console.warn(`[åˆå¹¶è§£ç ] ç‰‡æ®µè§£ç å°è¯• ${decodeAttempts}/${maxDecodeAttempts} å¤±è´¥:`, error.message);
                            
                            if (decodeAttempts >= maxDecodeAttempts) {
                                throw new Error(`ç‰‡æ®µè§£ç å¤±è´¥: ${error.message}`);
                            }
                            
                            await new Promise(resolve => setTimeout(resolve, 300));
                            await MobileAudioManager.ensureResumed();
                        }
                    }
                    
                    segments.push(audioBuffer);
                }
                
                // ç§»åŠ¨ç«¯å†…å­˜ä¼˜åŒ–ï¼šæ¯æ‰¹å¤„ç†åè§¦å‘åƒåœ¾å›æ”¶æç¤º
                if (window.gc) {
                    window.gc();
                }
            }

            // åˆ›å»ºåˆå¹¶åçš„buffer
            const totalLength = segments.reduce((sum, seg) => sum + seg.length, 0);
            const mergedBuffer = ctx.createBuffer(
                segments[0].numberOfChannels,
                totalLength,
                segments[0].sampleRate
            );

            // åˆå¹¶æ‰€æœ‰ç‰‡æ®µ
            let offset = 0;
            for (const segment of segments) {
                for (let channel = 0; channel < segment.numberOfChannels; channel++) {
                    const mergedData = mergedBuffer.getChannelData(channel);
                    const segmentData = segment.getChannelData(channel);
                    for (let i = 0; i < segmentData.length; i++) {
                        mergedData[offset + i] = segmentData[i];
                    }
                }
                offset += segment.length;
            }

            return audioBufferToWav(mergedBuffer);
        }

        // å·¥å…·å‡½æ•°ï¼šæ˜¾ç¤ºæµå¼å¤„ç†ä¿¡æ¯
        function showStreamingInfo() {
            elements.streamingInfo.style.display = 'block';
            streamingStats.startTime = Date.now();
        }

        // å·¥å…·å‡½æ•°ï¼šéšè—æµå¼å¤„ç†ä¿¡æ¯
        function hideStreamingInfo() {
            setTimeout(() => {
                elements.streamingInfo.style.display = 'none';
            }, 2000);
        }

        // å·¥å…·å‡½æ•°ï¼šåˆå§‹åŒ–ç‰‡æ®µåˆ—è¡¨
        function initSegmentList(numSegments) {
            elements.segmentList.innerHTML = '';
            streamingStats.totalSegments = numSegments;
            streamingStats.processedSegments = 0;
            streamingStats.successfulSegments = 0;
            streamingStats.failedSegments = 0;
            streamingStats.segments = new Array(numSegments).fill(null);
            
            elements.totalSegments.textContent = numSegments;
            elements.processedSegments.textContent = '0';
            elements.processingSpeed.textContent = '0/s';
            elements.successRate.textContent = '0%';
            
            for (let i = 0; i < numSegments; i++) {
                const segmentItem = document.createElement('div');
                segmentItem.className = 'segment-item pending';
                segmentItem.id = `segment-${i}`;
                segmentItem.innerHTML = `
                    <div class="segment-header">
                        <div class="segment-title">ç‰‡æ®µ ${i + 1}</div>
                        <span class="segment-badge bg-secondary">ç­‰å¾…ä¸­</span>
                    </div>
                    <div class="segment-details">å‡†å¤‡å¤„ç†...</div>
                `;
                elements.segmentList.appendChild(segmentItem);
            }
            
            showStreamingInfo();
        }

        // å·¥å…·å‡½æ•°ï¼šæ›´æ–°ç‰‡æ®µçŠ¶æ€
        function updateSegmentStatus(index, status, message = '') {
            const segmentItem = document.getElementById(`segment-${index}`);
            if (!segmentItem) return;
            
            segmentItem.className = `segment-item ${status}`;
            
            let badgeText = 'ç­‰å¾…ä¸­';
            let badgeClass = 'bg-secondary';
            
            switch(status) {
                case 'processing':
                    badgeText = 'å¤„ç†ä¸­';
                    badgeClass = 'bg-warning';
                    break;
                case 'processed':
                    badgeText = 'å·²å®Œæˆ';
                    badgeClass = 'bg-success';
                    streamingStats.processedSegments++;
                    streamingStats.successfulSegments++;
                    break;
                case 'error':
                    badgeText = 'å¤±è´¥';
                    badgeClass = 'bg-danger';
                    streamingStats.processedSegments++;
                    streamingStats.failedSegments++;
                    break;
            }
            
            segmentItem.innerHTML = `
                <div class="segment-header">
                    <div class="segment-title">ç‰‡æ®µ ${index + 1}</div>
                    <span class="segment-badge ${badgeClass}">${badgeText}</span>
                </div>
                <div class="segment-details">${message}</div>
            `;
            
            // æ›´æ–°æµå¼ç»Ÿè®¡
            updateStreamingStats();
        }

        // å·¥å…·å‡½æ•°ï¼šæ›´æ–°æµå¼ç»Ÿè®¡
        function updateStreamingStats() {
            elements.processedSegments.textContent = streamingStats.processedSegments;
            
            // è®¡ç®—å¤„ç†é€Ÿåº¦
            if (streamingStats.startTime && streamingStats.processedSegments > 0) {
                const elapsedTime = (Date.now() - streamingStats.startTime) / 1000;
                const speed = streamingStats.processedSegments / elapsedTime;
                elements.processingSpeed.textContent = `${speed.toFixed(1)}/s`;
                
                // è®¡ç®—æˆåŠŸç‡
                const successRate = streamingStats.successfulSegments / streamingStats.totalSegments * 100;
                elements.successRate.textContent = `${successRate.toFixed(1)}%`;
                
                // æ›´æ–°æ•´ä½“è¿›åº¦
                const overallProgress = (streamingStats.processedSegments / streamingStats.totalSegments) * 100;
                updateProgress(40 + (overallProgress * 0.5), `æ­£åœ¨å¤„ç†éŸ³é¢‘ç‰‡æ®µ: ${streamingStats.processedSegments}/${streamingStats.totalSegments}`);
                
                // é¢„ä¼°å‰©ä½™æ—¶é—´
                if (speed > 0) {
                    const remainingSegments = streamingStats.totalSegments - streamingStats.processedSegments;
                    const remainingTime = remainingSegments / speed;
                    if (remainingTime > 60) {
                        elements.estimatedRemaining.textContent = `${(remainingTime / 60).toFixed(1)}åˆ†é’Ÿ`;
                    } else {
                        elements.estimatedRemaining.textContent = `${remainingTime.toFixed(0)}ç§’`;
                    }
                }
            }
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            // åˆå§‹åŒ–ç§»åŠ¨ç«¯ AudioContext ç®¡ç†å™¨ï¼ˆä¼˜å…ˆæ‰§è¡Œï¼‰
            MobileAudioManager.init();
            
            // æ›¿æ¢ä¸å¯ç”¨çš„ Bootstrap Icons ä¸º Unicode ç¬¦å·
            replaceBootstrapIcons();
            
            // åˆå§‹åŒ– WASM éŸ³é¢‘å¤„ç†å™¨
            initWASMAudioProcessor();

            initEventListeners();
            checkServices();
            
            // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            // æ£€æŸ¥ AudioContext çŠ¶æ€ï¼Œå¦‚æœéœ€è¦åˆ™æ˜¾ç¤ºå¯ç”¨æç¤º
            const checkAudioContextState = async () => {
                const ctx = getAudioContext();
                
                // å¦‚æœ AudioContext å¤„äº suspended çŠ¶æ€ä¸”æ˜¯ç§»åŠ¨è®¾å¤‡ï¼Œæ˜¾ç¤ºå¯ç”¨æŒ‰é’®
                if (ctx.state === 'suspended' && isMobile) {
                    const prompt = document.getElementById('audio-enable-prompt');
                    if (prompt) {
                        prompt.style.display = 'flex';
                        console.log('[éŸ³é¢‘å¯ç”¨] æ˜¾ç¤ºå¯ç”¨æç¤ºæ¡†');
                    }
                }
            };
            
            // å»¶è¿Ÿæ£€æŸ¥ï¼Œç­‰å¾…åˆå§‹åŒ–å®Œæˆ
            setTimeout(checkAudioContextState, 1000);
            
            // éŸ³é¢‘å¯ç”¨æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            const enableAudioBtn = document.getElementById('enable-audio-btn');
            if (enableAudioBtn) {
                enableAudioBtn.addEventListener('click', async function() {
                    try {
                        showStatus('æ­£åœ¨å¯ç”¨éŸ³é¢‘åŠŸèƒ½...', 'loading');
                        
                        // å¼ºåˆ¶æ¢å¤ AudioContext
                        const success = await MobileAudioManager.ensureResumed();
                        
                        if (success) {
                            // æµ‹è¯•éŸ³é¢‘æ’­æ”¾
                            const testSuccess = await testAudioPlayback();
                            
                            if (testSuccess) {
                                // éšè—æç¤ºæ¡†
                                const prompt = document.getElementById('audio-enable-prompt');
                                if (prompt) {
                                    prompt.style.display = 'none';
                                }
                                
                                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                                this.innerHTML = '<i class="bi bi-check-circle"></i> å·²å¯ç”¨';
                                this.disabled = true;
                                this.classList.remove('btn-primary');
                                this.classList.add('btn-success');
                                
                                showStatus('éŸ³é¢‘åŠŸèƒ½å·²å¯ç”¨ï¼å¯ä»¥æ­£å¸¸æ’­æ”¾éŸ³é¢‘', 'success');
                                console.log('[éŸ³é¢‘å¯ç”¨] AudioContext æˆåŠŸæ¢å¤');
                                
                                // æ’­æ”¾ä¸€ä¸ªç®€çŸ­çš„æç¤ºéŸ³ï¼ˆå¯é€‰ï¼‰
                                playEnableSound();
                            } else {
                                showStatus('éŸ³é¢‘åŠŸèƒ½å·²å¯ç”¨ï¼Œä½†æµ‹è¯•æ’­æ”¾å¤±è´¥', 'warning');
                                console.warn('[éŸ³é¢‘å¯ç”¨] æµ‹è¯•æ’­æ”¾å¤±è´¥ï¼Œä½† AudioContext å·²æ¢å¤');
                            }
                        } else {
                            showStatus('éŸ³é¢‘å¯ç”¨å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                        }
                    } catch (error) {
                        console.error('[éŸ³é¢‘å¯ç”¨] å¯ç”¨å¤±è´¥:', error);
                        showStatus('éŸ³é¢‘å¯ç”¨å¤±è´¥: ' + error.message, 'error');
                    }
                });
            }
            
            // æ’­æ”¾å¯ç”¨æç¤ºéŸ³
            function playEnableSound() {
                try {
                    const ctx = getAudioContext();
                    const oscillator = ctx.createOscillator();
                    const gainNode = ctx.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(ctx.destination);
                    
                    oscillator.frequency.value = 800;
                    oscillator.type = 'sine';
                    gainNode.gain.value = 0.1;
                    
                    oscillator.start();
                    oscillator.stop(ctx.currentTime + 0.1);
                    
                    console.log('[éŸ³é¢‘å¯ç”¨] æ’­æ”¾æç¤ºéŸ³');
                } catch (error) {
                    console.warn('[éŸ³é¢‘å¯ç”¨] æç¤ºéŸ³æ’­æ”¾å¤±è´¥:', error);
                }
            }
            
            // æµ‹è¯•éŸ³é¢‘æ’­æ”¾åŠŸèƒ½
            async function testAudioPlayback() {
                console.log('[éŸ³é¢‘æµ‹è¯•] å¼€å§‹æµ‹è¯•éŸ³é¢‘æ’­æ”¾...');
                
                // åˆ›å»ºä¸€ä¸ªç®€çŸ­çš„æµ‹è¯•éŸ³é¢‘
                const ctx = getAudioContext();
                const sampleRate = ctx.sampleRate;
                const duration = 0.5; // 0.5ç§’
                const numSamples = sampleRate * duration;
                
                // åˆ›å»ºéŸ³é¢‘ç¼“å†²åŒº
                const buffer = ctx.createBuffer(1, numSamples, sampleRate);
                const data = buffer.getChannelData(0);
                
                // ç”Ÿæˆç®€å•çš„æ­£å¼¦æ³¢
                for (let i = 0; i < numSamples; i++) {
                    data[i] = Math.sin(2 * Math.PI * 440 * i / sampleRate) * 0.3;
                }
                
                // åˆ›å»ºæºå¹¶æ’­æ”¾
                const source = ctx.createBufferSource();
                source.buffer = buffer;
                source.connect(ctx.destination);
                
                try {
                    source.start();
                    console.log('[éŸ³é¢‘æµ‹è¯•] æµ‹è¯•éŸ³é¢‘æ’­æ”¾æˆåŠŸ');
                    return true;
                } catch (error) {
                    console.error('[éŸ³é¢‘æµ‹è¯•] æµ‹è¯•éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
                    return false;
                }
            }
            
            // ç§»åŠ¨ç«¯ä¿®å¤ï¼šä¸ºæ‰€æœ‰éŸ³é¢‘å…ƒç´ æ·»åŠ è§¦æ‘¸äº‹ä»¶ç›‘å¬
            const audioElements = document.querySelectorAll('audio');
            audioElements.forEach(audio => {
                // è§¦æ‘¸å¼€å§‹æ—¶æ¢å¤ AudioContext
                audio.addEventListener('touchstart', async function() {
                    await MobileAudioManager.ensureResumed();
                    console.log('[éŸ³é¢‘å…ƒç´ ] è§¦æ‘¸äº‹ä»¶è§¦å‘ï¼ŒAudioContext å·²æ¢å¤');
                }, { passive: true });
                
                // ç‚¹å‡»æ—¶æ¢å¤ AudioContext
                audio.addEventListener('click', async function() {
                    await MobileAudioManager.ensureResumed();
                    console.log('[éŸ³é¢‘å…ƒç´ ] ç‚¹å‡»äº‹ä»¶è§¦å‘ï¼ŒAudioContext å·²æ¢å¤');
                });
                
                // ç›‘å¬æ’­æ”¾é”™è¯¯
                audio.addEventListener('error', function(e) {
                    console.error('[éŸ³é¢‘å…ƒç´ ] æ’­æ”¾é”™è¯¯:', e.target.error);
                });
            });
            
            // ç§»åŠ¨ç«¯ä¿®å¤ï¼šåœ¨ä»»ä½•ç”¨æˆ·äº¤äº’åå¯ç”¨ AudioContext
            document.addEventListener('click', async function enableAudioContext() {
                const ctx = getAudioContext();
                if (ctx.state === 'suspended') {
                    try {
                        await ctx.resume();
                        console.log('[Init] AudioContext resumed on click');
                    } catch (err) {
                        console.warn('[Init] AudioContext resume failed on click:', err);
                    }
                }
                // åªéœ€è¦ä¸€æ¬¡ï¼Œä¹‹åç§»é™¤ç›‘å¬
                document.removeEventListener('click', enableAudioContext);
            }, { once: true });
        });
        
        // æ›¿æ¢ Bootstrap Iconsï¼ˆå› ä¸º CORS é—®é¢˜æ— æ³•åŠ è½½å­—ä½“ï¼‰
        function replaceBootstrapIcons() {
            const iconMap = {
                'bi-gear': 'âš™ï¸',
                'bi-gear-fill': 'âš™ï¸',
                'bi-download': 'â¬‡ï¸',
                'bi-magic': 'âœ¨',
                'bi-check-circle': 'âœ“',
                'bi-check-circle-fill': 'âœ“',
                'bi-exclamation-triangle': 'âš ï¸',
                'bi-x-circle': 'âœ—',
                'bi-info-circle': 'â„¹ï¸',
                'bi-arrow-right': 'â†’',
                'bi-clock': 'ğŸ•',
                'bi-clock-history': 'ğŸ“…',
                'bi-files': 'ğŸ“‹',
                'bi-file-earmark-music': 'ğŸµ',
                'bi-card-text': 'ğŸ“„',
                'bi-chat-square-text': 'ğŸ’¬',
                'bi-database': 'ğŸ’¾',
                'bi-graph-up': 'ğŸ“ˆ',
                'bi-cpu': 'ğŸ”§',
                'bi-hourglass': 'â³',
                'bi-hourglass-split': 'â³',
                'bi-arrow-repeat': 'ğŸ”„',
                'bi-check': 'âœ“'
            };
            
            document.querySelectorAll('[class*="bi-"]').forEach(el => {
                for (const [className, icon] of Object.entries(iconMap)) {
                    if (el.classList.contains(className)) {
                        // ä¿ç•™å…ƒç´ çš„å…¶ä»–å±æ€§ï¼Œåªæ›¿æ¢å›¾æ ‡å†…å®¹
                        if (el.tagName === 'I' && el.textContent.trim() === '') {
                            el.textContent = icon + ' ';
                        }
                        break;
                    }
                }
            });
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        function initEventListeners() {
            // TTSè¯­é€Ÿæ»‘å—
            elements.ttsSpeed.addEventListener('input', function() {
                elements.ttsSpeedValue.textContent = this.value;
            });

            // Tauæ»‘å—
            elements.tauSlider.addEventListener('input', function() {
                elements.tauValue.textContent = this.value;
            });

            // ç¤ºä¾‹æ–‡æœ¬æŒ‰é’®
            document.querySelectorAll('.example-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    elements.ttsText.value = this.getAttribute('data-text');
                    checkReadyToGenerate();
                    showStatus('å·²åŠ è½½ç¤ºä¾‹æ–‡æœ¬', 'info');
                });
            });

            // æ–‡æœ¬è¾“å…¥å˜åŒ–
            elements.ttsText.addEventListener('input', checkReadyToGenerate);

            // é«˜çº§é€‰é¡¹åˆ‡æ¢
            elements.toggleAdvanced.addEventListener('click', function() {
                const isVisible = elements.advancedOptions.style.display !== 'none';
                elements.advancedOptions.style.display = isVisible ? 'none' : 'block';
                this.innerHTML = isVisible ? 
                    '<i class="bi bi-gear"></i> é«˜çº§é€‰é¡¹' : 
                    '<i class="bi bi-gear-fill"></i> éšè—é«˜çº§é€‰é¡¹';
            });

            // ç›®æ ‡éŸ³è‰²ä¸Šä¼ 
            elements.targetDropZone.addEventListener('click', () => {
                elements.targetAudioFile.click();
            });

            elements.targetDropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                elements.targetDropZone.classList.add('dragover');
            });

            elements.targetDropZone.addEventListener('dragleave', () => {
                elements.targetDropZone.classList.remove('dragover');
            });

            elements.targetDropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                elements.targetDropZone.classList.remove('dragover');
                if (e.dataTransfer.files.length > 0) {
                    handleTargetAudio(e.dataTransfer.files[0]);
                }
            });

            elements.targetAudioFile.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleTargetAudio(e.target.files[0]);
                }
            });

            // ä¸€é”®ç”ŸæˆæŒ‰é’®
            elements.generateAllBtn.addEventListener('click', startCompleteWorkflow);
            
            // ä¸‹è½½æœ€ç»ˆç»“æœæŒ‰é’®
            elements.finalDownloadBtn.addEventListener('click', downloadFinalResult);
            
            // å®æ—¶ç»Ÿè®¡æ›´æ–°
            setInterval(updateRealTimeStats, 1000);
        }

        // æ£€æŸ¥æœåŠ¡çŠ¶æ€
        async function checkServices() {
            // æ£€æŸ¥TTSæœåŠ¡ - ä½¿ç”¨ /api/models æ¥å£
            try {
                const response = await fetch(`${TTS_SERVER}/api/models`);
                if (response.ok) {
                    const models = await response.json();
                    if (Array.isArray(models) && models.length > 0) {
                        elements.ttsServiceStatus.innerHTML = '<i class="bi bi-check-circle-fill"></i> TTSæœåŠ¡åœ¨çº¿';
                        elements.ttsServiceStatus.className = 'service-badge service-online';
                        console.log('[TTSæœåŠ¡] å¯ç”¨æ¨¡å‹:', models.map(m => m.name).join(', '));
                    } else {
                        elements.ttsServiceStatus.innerHTML = '<i class="bi bi-exclamation-triangle-fill"></i> TTSæœåŠ¡æ— æ¨¡å‹';
                        elements.ttsServiceStatus.className = 'service-badge service-offline';
                    }
                } else {
                    elements.ttsServiceStatus.innerHTML = '<i class="bi bi-x-circle-fill"></i> TTSæœåŠ¡ç¦»çº¿';
                    elements.ttsServiceStatus.className = 'service-badge service-offline';
                }
            } catch (error) {
                elements.ttsServiceStatus.innerHTML = '<i class="bi bi-x-circle-fill"></i> TTSæœåŠ¡ç¦»çº¿';
                elements.ttsServiceStatus.className = 'service-badge service-offline';
                console.error('[TTSæœåŠ¡] æ£€æŸ¥å¤±è´¥:', error);
            }

            // æ£€æŸ¥éŸ³è‰²å…‹éš†æœåŠ¡
            try {
                const response = await fetch(`${ISV_SERVER}/api/health`);
                if (response.ok) {
                    elements.isvServiceStatus.innerHTML = '<i class="bi bi-check-circle-fill"></i> éŸ³è‰²å…‹éš†æœåŠ¡åœ¨çº¿';
                    elements.isvServiceStatus.className = 'service-badge service-online';
                }
            } catch (error) {
                elements.isvServiceStatus.innerHTML = '<i class="bi bi-x-circle-fill"></i> éŸ³è‰²å…‹éš†æœåŠ¡ç¦»çº¿';
                elements.isvServiceStatus.className = 'service-badge service-offline';
                console.error('[ISVæœåŠ¡] æ£€æŸ¥å¤±è´¥:', error);
            }
        }

        // å¤„ç†ç›®æ ‡éŸ³é¢‘

                async function handleTargetAudio(file) {
                    if (!file.type.startsWith('audio/')) {
                        showStatus('è¯·ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶ï¼ˆWAVã€MP3ã€FLACã€OGGæ ¼å¼ï¼‰', 'error');
                        return;
                    }

                    // é™åˆ¶æ–‡ä»¶å¤§å°
                    if (file.size > 10 * 1024 * 1024) { // 10MBé™åˆ¶
                        showStatus('æ–‡ä»¶å¤ªå¤§ï¼Œè¯·ä¸Šä¼ å°äº10MBçš„éŸ³é¢‘æ–‡ä»¶', 'error');
                        return;
                    }

                    // ç¡®ä¿ AudioContext å·²æ¢å¤ï¼ˆç§»åŠ¨ç«¯å…³é”®ï¼‰
                    await MobileAudioManager.ensureResumed();

                    targetAudioBlob = file;
                    
                    // æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
                    elements.targetFileName.textContent = file.name;
                    elements.targetFileSize.textContent = formatFileSize(file.size);
                    
                    elements.targetAudioInfo.style.display = 'block';
                    
                    // åˆ›å»ºéŸ³é¢‘URL
                    const audioUrl = URL.createObjectURL(file);
                    elements.targetAudioPlayer.src = audioUrl;
                    
                    // ç§»åŠ¨ç«¯ä¿®å¤ï¼šé‡ç½®éŸ³é¢‘å…ƒç´ 
                    elements.targetAudioPlayer.currentTime = 0;
                    elements.targetAudioPlayer.volume = 1.0;
                    
                    // ç§»åŠ¨ç«¯ä¿®å¤ï¼šé¢„åŠ è½½éŸ³é¢‘
                    elements.targetAudioPlayer.load();
                    
                    // ç§»åŠ¨ç«¯ä¿®å¤ï¼šç›‘å¬éŸ³é¢‘å°±ç»ªäº‹ä»¶
                    elements.targetAudioPlayer.oncanplay = () => {
                        console.log('[ç›®æ ‡éŸ³é¢‘] éŸ³é¢‘å·²å°±ç»ªï¼Œå¯ä»¥æ’­æ”¾');
                        console.log('[ç›®æ ‡éŸ³é¢‘] æ—¶é•¿:', elements.targetAudioPlayer.duration, 'ç§’');
                        console.log('[ç›®æ ‡éŸ³é¢‘] å°±ç»ªçŠ¶æ€:', elements.targetAudioPlayer.readyState);
                    };
                    
                    // ç§»åŠ¨ç«¯ä¿®å¤ï¼šç›‘å¬æ’­æ”¾é”™è¯¯
                    elements.targetAudioPlayer.onerror = (e) => {
                        console.error('[ç›®æ ‡éŸ³é¢‘] éŸ³é¢‘åŠ è½½å¤±è´¥:', e);
                        console.error('[ç›®æ ‡éŸ³é¢‘] é”™è¯¯ä»£ç :', elements.targetAudioPlayer.error);
                        console.error('[ç›®æ ‡éŸ³é¢‘] é”™è¯¯è¯¦æƒ…:', elements.targetAudioPlayer.error ? elements.targetAudioPlayer.error.message : 'æœªçŸ¥é”™è¯¯');
                        showStatus('éŸ³é¢‘åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
                    };
                    
                    // ç§»åŠ¨ç«¯ä¿®å¤ï¼šç›‘å¬åŠ è½½æˆåŠŸ
                    elements.targetAudioPlayer.onloadeddata = () => {
                        console.log('[ç›®æ ‡éŸ³é¢‘] éŸ³é¢‘æ•°æ®å·²åŠ è½½');
                    };
                    
                    // ç§»åŠ¨ç«¯ä¿®å¤ï¼šç›‘å¬åŠ è½½å…ƒæ•°æ®
                    elements.targetAudioPlayer.onloadedmetadata = () => {
                        console.log('[ç›®æ ‡éŸ³é¢‘] éŸ³é¢‘å…ƒæ•°æ®å·²åŠ è½½');
                        console.log('[ç›®æ ‡éŸ³é¢‘] é‡‡æ ·ç‡:', elements.targetAudioPlayer.sampleRate || 'æœªçŸ¥');
                        console.log('[ç›®æ ‡éŸ³é¢‘] å£°é“æ•°:', elements.targetAudioPlayer.mozChannels || elements.targetAudioPlayer.webkitAudioDecodedByteCount ? 'å·²è§£ç ' : 'æœªçŸ¥');
                    };
                    
                    // ç§»åŠ¨ç«¯ä¿®å¤ï¼šæ·»åŠ è§¦æ‘¸äº‹ä»¶ç›‘å¬ï¼Œç¡®ä¿ç”¨æˆ·äº¤äº’åå¯ä»¥æ’­æ”¾
                    const enablePlay = async () => {
                        try {
                            await MobileAudioManager.ensureResumed();
                            console.log('[ç›®æ ‡éŸ³é¢‘] è§¦æ‘¸äº‹ä»¶ï¼ŒAudioContext å·²æ¢å¤');
                            
                            // å°è¯•æ’­æ”¾ä¸€å°æ®µéŸ³é¢‘æ¥æ¿€æ´»
                            if (elements.targetAudioPlayer.paused) {
                                elements.targetAudioPlayer.play().then(() => {
                                    console.log('[ç›®æ ‡éŸ³é¢‘] è‡ªåŠ¨æ’­æ”¾æˆåŠŸ');
                                    elements.targetAudioPlayer.pause(); // ç«‹å³æš‚åœï¼Œåªæ˜¯ä¸ºäº†æ¿€æ´»
                                    elements.targetAudioPlayer.currentTime = 0; // é‡ç½®åˆ°å¼€å¤´
                                }).catch(err => {
                                    console.log('[ç›®æ ‡éŸ³é¢‘] è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼ˆæ­£å¸¸ï¼‰:', err.message);
                                });
                            }
                        } catch (error) {
                            console.warn('[ç›®æ ‡éŸ³é¢‘] å¯ç”¨æ’­æ”¾å¤±è´¥:', error);
                        }
                    };
                    
                    // æ·»åŠ ä¸€æ¬¡æ€§è§¦æ‘¸äº‹ä»¶
                    elements.targetAudioPlayer.addEventListener('touchstart', enablePlay, { once: true });
                    elements.targetAudioPlayer.addEventListener('click', enablePlay, { once: true });
                    
                    // æ›´æ–°æ–‡ä»¶çŠ¶æ€æ˜¾ç¤º
                    elements.fileStatusTarget.className = 'file-status ready';
                    elements.fileStatusTarget.querySelector('.file-status-icon').innerHTML = '<i class="bi bi-check-circle"></i>';
                    elements.fileStatusTarget.querySelector('p').textContent = `å·²ä¸Šä¼ : ${file.name}`;
                    
                    // æ£€æŸ¥æ˜¯å¦å¯ä»¥è¿›è¡Œå…‹éš†
                    checkReadyToGenerate();
                    
                    showStatus('ç›®æ ‡éŸ³è‰²å·²ä¸Šä¼ ï¼Œç‚¹å‡»æ’­æ”¾å™¨è¯•å¬', 'success');
                }

        // å¼€å§‹å®Œæ•´å·¥ä½œæµ
        async function startCompleteWorkflow() {
            const text = elements.ttsText.value.trim();
            if (!text) {
                showStatus('è¯·è¾“å…¥è¦è½¬æ¢çš„æ–‡æœ¬', 'error');
                return;
            }

            if (!targetAudioBlob) {
                showStatus('è¯·ä¸Šä¼ ç›®æ ‡éŸ³è‰²éŸ³é¢‘', 'error');
                return;
            }

            // é‡ç½®çŠ¶æ€
            processingStartTime = Date.now();
            ttsStartTime = 0;
            cloneStartTime = 0;
            totalProcessingTime = 0;
            
            // é‡ç½®å¤„ç†æ­¥éª¤
            updateProcessingStep('tts', '');
            updateProcessingStep('clone', '');
            updateProcessingStep('merge', '');
            
            showStatus('å¼€å§‹ä¸€é”®ç”Ÿæˆå…‹éš†è¯­éŸ³...', 'loading');
            showProgress();
            updateProgress(10, 'æ­£åœ¨åˆå§‹åŒ–...');
            
            elements.generateAllBtn.disabled = true;
            elements.generateAllBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> å¤„ç†ä¸­...';
            
            // éšè—ä¹‹å‰çš„ç»“æœ
            elements.resultContainer.style.display = 'none';
            // éšè—æµå¼å¤„ç†ä¿¡æ¯ï¼ˆå¦‚æœéœ€è¦ä¼šé‡æ–°æ˜¾ç¤ºï¼‰
            hideStreamingInfo();

            try {
                // æ­¥éª¤1: ç”ŸæˆTTSè¯­éŸ³
                updateProcessingStep('tts', 'active', 'æ­£åœ¨å°†æ–‡æœ¬è½¬æ¢ä¸ºè¯­éŸ³...');
                updateProgress(20, 'æ­£åœ¨ç”ŸæˆTTSè¯­éŸ³...');
                updateWorkflowStep('step4');
                
                const ttsStart = Date.now();
                const ttsAudioBlob = await generateTTS(text);
                ttsStartTime = Date.now() - ttsStart;
                
                updateProcessingStep('tts', 'completed', `TTSç”Ÿæˆå®Œæˆ (${(ttsStartTime/1000).toFixed(2)}ç§’)`);
                updateProgress(40, 'TTSè¯­éŸ³ç”Ÿæˆå®Œæˆï¼Œå¼€å§‹éŸ³è‰²å…‹éš†...');

                // æ­¥éª¤2: éŸ³è‰²å…‹éš†
                updateProcessingStep('clone', 'active', 'å‡†å¤‡éŸ³è‰²å…‹éš†...');
                
                const cloneStart = Date.now();
                const clonedResult = await cloneVoice(ttsAudioBlob, targetAudioBlob);
                cloneStartTime = Date.now() - cloneStart;
                
                updateProcessingStep('clone', 'completed', `éŸ³è‰²å…‹éš†å®Œæˆ (${(cloneStartTime/1000).toFixed(2)}ç§’)`);
                updateProgress(90, 'éŸ³è‰²å…‹éš†å®Œæˆï¼Œæ­£åœ¨ä¼˜åŒ–éŸ³é¢‘...');

                // æ­¥éª¤3: åˆå¹¶ä¸ä¼˜åŒ–
                updateProcessingStep('merge', 'active', 'æ­£åœ¨åˆå¹¶éŸ³é¢‘ç‰‡æ®µ...');
                
                // å¦‚æœè¿”å›çš„æ˜¯å¤šä¸ªç‰‡æ®µï¼Œéœ€è¦åˆå¹¶
                if (clonedResult.segments && clonedResult.segments.length > 1) {
                    const mergedWavBlob = await mergeAudioSegments(clonedResult.segments);
                    clonedAudioBlob = mergedWavBlob;
                    clonedAudioBase64 = (await blobToBase64(mergedWavBlob)).split(',')[1];
                } else {
                    clonedAudioBase64 = clonedResult.audio;
                    // å°†å•æ®µçš„ base64 è½¬æ¢ä¸º Blob
                    const binaryString = atob(clonedAudioBase64);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    clonedAudioBlob = new Blob([bytes.buffer], { type: 'audio/wav' });
                }
                
                updateProcessingStep('merge', 'completed', 'éŸ³é¢‘åˆå¹¶å®Œæˆ');
                updateProgress(100, 'å¤„ç†å®Œæˆ!');
                updateWorkflowStep('step5');
                
                // è®¡ç®—æ€»è€—æ—¶
                totalProcessingTime = Date.now() - processingStartTime;
                
                // æ˜¾ç¤ºæœ€ç»ˆç»“æœ
                showFinalResult(clonedResult);
                
                showStatus(`ä¸€é”®ç”Ÿæˆå®Œæˆ! æ€»è€—æ—¶: ${(totalProcessingTime/1000).toFixed(2)}ç§’`, 'success');

            } catch (error) {
                console.error('ä¸€é”®ç”Ÿæˆå¤±è´¥:', error);
                showStatus(`å¤„ç†å¤±è´¥: ${error.message}`, 'error');
            } finally {
                elements.generateAllBtn.disabled = false;
                elements.generateAllBtn.innerHTML = '<i class="bi bi-magic"></i> ä¸€é”®ç”Ÿæˆå…‹éš†è¯­éŸ³';
                hideProgress();
                hideStreamingInfo();
            }
        }

        // ç”ŸæˆTTSè¯­éŸ³
        async function generateTTS(text) {
            try {
                const response = await fetch(`${TTS_SERVER}/api/tts`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        text: text,
                        model: elements.ttsModel.value,
                        speed: parseFloat(elements.ttsSpeed.value),
                        volume: 1.0,
                        noise_scale: 0.667,
                        sentence_silence: 0.5
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`TTSç”Ÿæˆå¤±è´¥: ${response.status} - ${errorText.substring(0, 100)}`);
                }

                // è·å–éŸ³é¢‘æ•°æ®
                return await response.blob();

            } catch (error) {
                console.error('TTSç”Ÿæˆå¤±è´¥:', error);
                throw new Error(`TTSç”Ÿæˆå¤±è´¥: ${error.message}`);
            }
        }

        // éŸ³è‰²å…‹éš†
        async function cloneVoice(ttsAudioBlob, targetAudioBlob) {
            // ç¡®ä¿ AudioContext å·²æ¢å¤
            await MobileAudioManager.ensureResumed();
            
            // è½¬æ¢ç›®æ ‡éŸ³è‰²ä¸ºbase64
            const targetBase64 = await fileToBase64(targetAudioBlob);
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦æµå¼å¤„ç†
            const shouldStream = elements.enableStreaming.checked;
            console.log('[éŸ³è‰²å…‹éš†] æµå¼å¤„ç†å¼€å…³:', shouldStream);
            
            if (shouldStream) {
                // æ£€æŸ¥éŸ³é¢‘é•¿åº¦
                const audioUrl = URL.createObjectURL(ttsAudioBlob);
                const audioElement = new Audio(audioUrl);
                
                try {
                    await new Promise((resolve, reject) => {
                        const timeoutId = setTimeout(() => {
                            console.warn('[éŸ³è‰²å…‹éš†] éŸ³é¢‘åŠ è½½è¶…æ—¶ï¼Œä½¿ç”¨é»˜è®¤å€¼');
                            resolve();
                        }, 5000); // 5ç§’è¶…æ—¶
                        
                        audioElement.addEventListener('loadedmetadata', () => {
                            clearTimeout(timeoutId);
                            console.log('[éŸ³è‰²å…‹éš†] éŸ³é¢‘å…ƒæ•°æ®åŠ è½½æˆåŠŸï¼Œæ—¶é•¿:', audioElement.duration, 'ç§’');
                            resolve();
                        });
                        
                        audioElement.addEventListener('error', (e) => {
                            clearTimeout(timeoutId);
                            console.error('[éŸ³è‰²å…‹éš†] éŸ³é¢‘åŠ è½½å¤±è´¥:', e);
                            console.error('[éŸ³è‰²å…‹éš†] é”™è¯¯è¯¦æƒ…:', audioElement.error);
                            resolve(); // ç»§ç»­å¤„ç†ï¼Œä½¿ç”¨é»˜è®¤å€¼
                        });
                        
                        audioElement.load();
                    });
                    
                    const audioDuration = audioElement.duration || 0;
                    const segmentDuration = parseInt(elements.segmentDuration.value);
                    
                    // ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šé™ä½æµå¼å¤„ç†é˜ˆå€¼
                    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                    const streamingThreshold = segmentDuration * 1.5; // é™ä½ç§»åŠ¨ç«¯é˜ˆå€¼
                    
                    console.log('[éŸ³è‰²å…‹éš†] éŸ³é¢‘æ—¶é•¿:', audioDuration.toFixed(2), 'ç§’');
                    console.log('[éŸ³è‰²å…‹éš†] ç‰‡æ®µæ—¶é•¿:', segmentDuration, 'ç§’');
                    console.log('[éŸ³è‰²å…‹éš†] æµå¼é˜ˆå€¼:', streamingThreshold.toFixed(2), 'ç§’');
                    console.log('[éŸ³è‰²å…‹éš†] æ˜¯å¦ä½¿ç”¨æµå¼å¤„ç†:', audioDuration > streamingThreshold);
                    
                    // å¦‚æœéŸ³é¢‘è¾ƒé•¿ï¼Œä½¿ç”¨æµå¼å¤„ç†
                    if (audioDuration > streamingThreshold) {
                        showStatus(`éŸ³é¢‘è¾ƒé•¿(${audioDuration.toFixed(2)}ç§’)ï¼Œå¯ç”¨æµå¼å¤„ç†`, 'info');
                        return await streamingClone(targetBase64, ttsAudioBlob);
                    } else {
                        console.log('[éŸ³è‰²å…‹éš†] éŸ³é¢‘è¾ƒçŸ­ï¼Œä½¿ç”¨å•æ¬¡å¤„ç†');
                    }
                } catch (error) {
                    console.error('[éŸ³è‰²å…‹éš†] æ£€æµ‹éŸ³é¢‘é•¿åº¦å¤±è´¥:', error);
                    // å‡ºé”™æ—¶ä½¿ç”¨å•æ¬¡å¤„ç†
                }
            }
            
            // å•æ¬¡å¤„ç†
            showStatus('ä½¿ç”¨å•æ¬¡å¤„ç†æ¨¡å¼', 'info');
            return await singleClone(targetBase64, ttsAudioBlob);
        }

        // å•æ¬¡éŸ³è‰²å…‹éš†
        async function singleClone(targetBase64, ttsAudioBlob) {
            const sourceBase64 = await blobToBase64(ttsAudioBlob);
            
            const response = await fetch(`${ISV_SERVER}/api/clone`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    target_audio: targetBase64,
                    source_audio: sourceBase64,
                    tau: parseFloat(elements.tauSlider.value)
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`éŸ³è‰²å…‹éš†å¤±è´¥: ${response.status} - ${errorText.substring(0, 100)}`);
            }

            const result = await response.json();
            
            if (result.success) {
                return {
                    audio: result.result_audio,
                    segments: [result.result_audio],
                    stats: result.stats || {}
                };
            } else {
                throw new Error(result.error || 'éŸ³è‰²å…‹éš†å¤±è´¥');
            }
        }

        // æµå¼éŸ³è‰²å…‹éš†
        async function streamingClone(targetBase64, ttsAudioBlob) {
            // ç¡®ä¿ AudioContext å·²æ¢å¤
            await MobileAudioManager.ensureResumed();
            
            showStatus('å¼€å§‹æµå¼å¤„ç†éŸ³é¢‘...', 'info');
            console.log('[æµå¼å¤„ç†] ========== å¼€å§‹æµå¼å¤„ç† ==========');
            
            // è·å–éŸ³é¢‘ä¿¡æ¯
            const audioUrl = URL.createObjectURL(ttsAudioBlob);
            const audioElement = new Audio(audioUrl);
            
            try {
                await new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        console.warn('[æµå¼å¤„ç†] éŸ³é¢‘åŠ è½½è¶…æ—¶');
                        resolve();
                    }, 5000);
                    
                    audioElement.addEventListener('loadedmetadata', () => {
                        clearTimeout(timeoutId);
                        console.log('[æµå¼å¤„ç†] éŸ³é¢‘å…ƒæ•°æ®åŠ è½½æˆåŠŸ');
                        resolve();
                    });
                    
                    audioElement.addEventListener('error', (e) => {
                        clearTimeout(timeoutId);
                        console.error('[æµå¼å¤„ç†] éŸ³é¢‘åŠ è½½å¤±è´¥:', e);
                        reject(new Error('éŸ³é¢‘åŠ è½½å¤±è´¥'));
                    });
                    
                    audioElement.load();
                });
            } catch (error) {
                console.error('[æµå¼å¤„ç†] è·å–éŸ³é¢‘ä¿¡æ¯å¤±è´¥:', error);
                throw new Error('æ— æ³•è·å–éŸ³é¢‘ä¿¡æ¯ï¼Œæµå¼å¤„ç†å¤±è´¥');
            }
            
            const audioDuration = audioElement.duration || 0;
            const segmentDuration = parseInt(elements.segmentDuration.value);
            
            // ç§»åŠ¨ç«¯ä¼˜åŒ–ï¼šæ ¹æ®è®¾å¤‡æ€§èƒ½è°ƒæ•´å¹¶å‘æ•°
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            const mobileConcurrentLimit = isMobile ? 2 : parseInt(elements.concurrentCount.value);
            
            console.log('[æµå¼å¤„ç†] éŸ³é¢‘æ€»æ—¶é•¿:', audioDuration.toFixed(2), 'ç§’');
            console.log('[æµå¼å¤„ç†] ç‰‡æ®µæ—¶é•¿:', segmentDuration, 'ç§’');
            console.log('[æµå¼å¤„ç†] å¹¶å‘æ•°:', mobileConcurrentLimit);
            console.log('[æµå¼å¤„ç†] æ˜¯å¦ç§»åŠ¨ç«¯:', isMobile);
            
            showStatus(`å¼€å§‹æµå¼å¤„ç†: å°†${audioDuration.toFixed(2)}ç§’éŸ³é¢‘åˆ‡åˆ†ä¸ºç‰‡æ®µ`, 'info');
            
            // åˆ‡åˆ†éŸ³é¢‘
            updateProcessingStep('clone', 'active', `æ­£åœ¨åˆ‡åˆ†éŸ³é¢‘ (${audioDuration.toFixed(2)}ç§’)`);
            
            let splitResult;
            try {
                splitResult = await splitAudioIntoSegments(ttsAudioBlob, segmentDuration);
                console.log('[æµå¼å¤„ç†] éŸ³é¢‘åˆ‡åˆ†æˆåŠŸï¼Œç‰‡æ®µæ•°:', splitResult.numSegments);
            } catch (error) {
                console.error('[æµå¼å¤„ç†] éŸ³é¢‘åˆ‡åˆ†å¤±è´¥:', error);
                throw new Error('éŸ³é¢‘åˆ‡åˆ†å¤±è´¥: ' + error.message);
            }
            
            const numSegments = splitResult.numSegments;
            
            // åˆå§‹åŒ–ç‰‡æ®µåˆ—è¡¨
            initSegmentList(numSegments);
            
            updateProcessingStep('clone', 'active', `å¼€å§‹å¤„ç† ${numSegments} ä¸ªç‰‡æ®µ...`);
            
            // å¹¶å‘å¤„ç†ç‰‡æ®µ
            const concurrentLimit = mobileConcurrentLimit;
            const segments = splitResult.segments;
            const segmentResults = new Array(numSegments);
            
            console.log('[æµå¼å¤„ç†] å¼€å§‹åˆ†æ‰¹å¤„ç†ï¼Œæ‰¹æ¬¡å¤§å°:', concurrentLimit);
            
            // åˆ†æ‰¹å¤„ç†
            for (let i = 0; i < segments.length; i += concurrentLimit) {
                const batch = segments.slice(i, i + concurrentLimit);
                console.log(`[æµå¼å¤„ç†] å¤„ç†æ‰¹æ¬¡ ${Math.floor(i / concurrentLimit) + 1}/${Math.ceil(segments.length / concurrentLimit)}`);
                
                // æ›´æ–°å½“å‰å¤„ç†ä¸­çš„ç‰‡æ®µçŠ¶æ€
                batch.forEach(segment => {
                    updateSegmentStatus(segment.index, 'processing', `å‡†å¤‡å¤„ç† (${segment.duration.toFixed(1)}ç§’)`);
                });
                
                // åˆ›å»ºæ‰¹æ¬¡å¤„ç†Promise
                const batchPromises = batch.map(async (segment) => {
                    try {
                        updateSegmentStatus(segment.index, 'processing', 'å‘é€è¯·æ±‚åˆ°æœåŠ¡å™¨...');
                        
                        const requestData = {
                            target_audio: targetBase64,
                            source_audio: segment.base64,
                            tau: parseFloat(elements.tauSlider.value)
                        };
                        
                        console.log(`[æµå¼å¤„ç†] ç‰‡æ®µ ${segment.index + 1}: å‘é€è¯·æ±‚ï¼Œæ•°æ®å¤§å°: ${(segment.base64.length / 1024).toFixed(2)}KB`);
                        
                        const response = await fetch(`${ISV_SERVER}/api/clone`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(requestData)
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            console.error(`[æµå¼å¤„ç†] ç‰‡æ®µ ${segment.index + 1} HTTP ${response.status}:`, errorText);
                            throw new Error(`ç‰‡æ®µ ${segment.index + 1} è¯·æ±‚å¤±è´¥ (HTTP ${response.status})`);
                        }

                        const result = await response.json();
                        
                        if (result.success) {
                            segmentResults[segment.index] = result.result_audio;
                            updateSegmentStatus(segment.index, 'processed', `å¤„ç†å®Œæˆ (${segment.duration.toFixed(1)}ç§’)`);
                            console.log(`[æµå¼å¤„ç†] ç‰‡æ®µ ${segment.index + 1} å¤„ç†æˆåŠŸ`);
                            
                            // ç§»åŠ¨ç«¯å†…å­˜ä¼˜åŒ–ï¼šé‡Šæ”¾ä¸å†éœ€è¦çš„èµ„æº
                            segment.base64 = null;
                            
                            return result;
                        } else {
                            throw new Error(result.error || 'ç‰‡æ®µå¤„ç†å¤±è´¥');
                        }
                    } catch (error) {
                        console.error(`[æµå¼å¤„ç†] ç‰‡æ®µ ${segment.index + 1} å¤„ç†å¤±è´¥:`, error);
                        updateSegmentStatus(segment.index, 'error', error.message);
                        throw error;
                    }
                });
                
                // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
                try {
                    await Promise.all(batchPromises);
                } catch (error) {
                    // å•ä¸ªç‰‡æ®µå¤±è´¥ä¸å½±å“å…¶ä»–ç‰‡æ®µ
                    showStatus(`éƒ¨åˆ†ç‰‡æ®µå¤„ç†å¤±è´¥ï¼Œç»§ç»­å¤„ç†å…¶ä»–ç‰‡æ®µ`, 'warning');
                }
                
                // ç§»åŠ¨ç«¯å†…å­˜ä¼˜åŒ–ï¼šæ¯æ‰¹å¤„ç†åé‡Šæ”¾å†…å­˜
                if (window.gc) {
                    window.gc();
                }
            }
            
            updateProcessingStep('clone', 'active', 'æ­£åœ¨åˆå¹¶éŸ³é¢‘ç‰‡æ®µ...');
            
            // è¿‡æ»¤å‡ºæˆåŠŸçš„ç‰‡æ®µ
            const successfulSegments = segmentResults.filter(result => result !== undefined);
            
            if (successfulSegments.length === 0) {
                throw new Error('æ‰€æœ‰ç‰‡æ®µå¤„ç†éƒ½å¤±è´¥äº†');
            }
            
            return {
                audio: successfulSegments[0], // ç®€åŒ–ï¼šä½¿ç”¨ç¬¬ä¸€ä¸ªç‰‡æ®µä½œä¸ºä»£è¡¨
                segments: successfulSegments,
                stats: {
                    total_segments: numSegments,
                    successful_segments: successfulSegments.length,
                    failed_segments: numSegments - successfulSegments.length
                }
            };
        }

        // æ›´æ–°å®æ—¶ç»Ÿè®¡
        function updateRealTimeStats() {
            if (!processingStartTime) return;
            
            const elapsed = (Date.now() - processingStartTime) / 1000;
            elements.elapsedTime.textContent = `${elapsed.toFixed(1)}ç§’`;
        }

        // æ˜¾ç¤ºæœ€ç»ˆç»“æœ
        async function showFinalResult(result) {
            // ç¡®ä¿ AudioContext å·²æ¢å¤ï¼ˆç§»åŠ¨ç«¯å…³é”®ï¼‰
            await MobileAudioManager.ensureResumed();

            // åˆ›å»ºéŸ³é¢‘ Blob URL
            if (clonedAudioBlob) {
                const audioUrl = URL.createObjectURL(clonedAudioBlob);
                elements.finalResultAudio.src = audioUrl;
                
                // ç§»åŠ¨ç«¯ä¿®å¤ï¼šé‡ç½®éŸ³é¢‘å…ƒç´ 
                elements.finalResultAudio.currentTime = 0;
                elements.finalResultAudio.volume = 1.0;
                
                // ç§»åŠ¨ç«¯ä¿®å¤ï¼šé¢„åŠ è½½éŸ³é¢‘
                elements.finalResultAudio.load();
                
                // ç§»åŠ¨ç«¯ä¿®å¤ï¼šç¡®ä¿éŸ³é¢‘å…ƒç´ å‡†å¤‡å°±ç»ª
                elements.finalResultAudio.oncanplay = () => {
                    console.log('[æ’­æ”¾å™¨] éŸ³é¢‘å·²å°±ç»ªï¼Œå¯ä»¥æ’­æ”¾');
                    console.log('[æ’­æ”¾å™¨] æ—¶é•¿:', elements.finalResultAudio.duration, 'ç§’');
                };
                
                // ç§»åŠ¨ç«¯ä¿®å¤ï¼šç›‘å¬åŠ è½½æˆåŠŸ
                elements.finalResultAudio.onloadeddata = () => {
                    console.log('[æ’­æ”¾å™¨] éŸ³é¢‘æ•°æ®å·²åŠ è½½');
                };
                
                // ç§»åŠ¨ç«¯ä¿®å¤ï¼šç›‘å¬æ’­æ”¾é”™è¯¯
                elements.finalResultAudio.onerror = (e) => {
                    console.error('[æ’­æ”¾å™¨] éŸ³é¢‘åŠ è½½å¤±è´¥:', e);
                    console.error('[æ’­æ”¾å™¨] é”™è¯¯ä»£ç :', elements.finalResultAudio.error);
                    console.error('[æ’­æ”¾å™¨] é”™è¯¯è¯¦æƒ…:', elements.finalResultAudio.error ? elements.finalResultAudio.error.message : 'æœªçŸ¥é”™è¯¯');
                };
                
                // ç§»åŠ¨ç«¯ä¿®å¤ï¼šæ·»åŠ è§¦æ‘¸äº‹ä»¶ç›‘å¬ï¼Œç¡®ä¿ç”¨æˆ·äº¤äº’åå¯ä»¥æ’­æ”¾
                const enablePlay = async () => {
                    try {
                        await MobileAudioManager.ensureResumed();
                        console.log('[æ’­æ”¾å™¨] è§¦æ‘¸äº‹ä»¶ï¼ŒAudioContext å·²æ¢å¤');
                        
                        // å°è¯•æ’­æ”¾ä¸€å°æ®µéŸ³é¢‘æ¥æ¿€æ´»
                        if (elements.finalResultAudio.paused) {
                            elements.finalResultAudio.play().then(() => {
                                console.log('[æ’­æ”¾å™¨] è‡ªåŠ¨æ’­æ”¾æˆåŠŸ');
                                elements.finalResultAudio.pause(); // ç«‹å³æš‚åœï¼Œåªæ˜¯ä¸ºäº†æ¿€æ´»
                                elements.finalResultAudio.currentTime = 0; // é‡ç½®åˆ°å¼€å¤´
                            }).catch(err => {
                                console.log('[æ’­æ”¾å™¨] è‡ªåŠ¨æ’­æ”¾è¢«é˜»æ­¢ï¼ˆæ­£å¸¸ï¼‰:', err.message);
                            });
                        }
                    } catch (error) {
                        console.warn('[æ’­æ”¾å™¨] å¯ç”¨æ’­æ”¾å¤±è´¥:', error);
                    }
                };
                
                // æ·»åŠ ä¸€æ¬¡æ€§è§¦æ‘¸äº‹ä»¶
                elements.finalResultAudio.addEventListener('touchstart', enablePlay, { once: true });
                elements.finalResultAudio.addEventListener('click', enablePlay, { once: true });
            }
            
            // æ˜¾ç¤ºç»“æœå®¹å™¨
            elements.resultContainer.style.display = 'block';
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            elements.ttsTime.textContent = `${(ttsStartTime/1000).toFixed(2)}ç§’`;
            elements.cloneTime.textContent = `${(cloneStartTime/1000).toFixed(2)}ç§’`;
            elements.totalTime.textContent = `${(totalProcessingTime/1000).toFixed(2)}ç§’`;
            
            // å¦‚æœæœ‰æµå¼å¤„ç†ç»Ÿè®¡ä¿¡æ¯
            if (result.stats && result.stats.total_segments) {
                elements.segmentCount.textContent = `${result.stats.successful_segments}/${result.stats.total_segments}ä¸ªç‰‡æ®µ`;
            } else {
                elements.segmentCount.textContent = 'å•æ¬¡å¤„ç†';
            }
            
            // æ»šåŠ¨åˆ°ç»“æœä½ç½®
            elements.resultContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            
            // æç¤ºç”¨æˆ·ç‚¹å‡»æ’­æ”¾
            showStatus('å¤„ç†å®Œæˆï¼ç‚¹å‡»æ’­æ”¾å™¨è¯•å¬å…‹éš†è¯­éŸ³', 'success');
        }

        // ä¸‹è½½æœ€ç»ˆç»“æœ
        function downloadFinalResult() {
            if (!clonedAudioBlob) {
                showStatus('æ²¡æœ‰å¯ä¸‹è½½çš„éŸ³é¢‘', 'error');
                return;
            }
            
            try {
                // ä½¿ç”¨ Blob å’Œ Object URL å®ç°å¯é çš„ä¸‹è½½
                const url = URL.createObjectURL(clonedAudioBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `å…‹éš†è¯­éŸ³_${new Date().toISOString().slice(0, 19).replace(/[:-]/g, '')}.wav`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // é‡Šæ”¾å¯¹è±¡ URL
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                showStatus('éŸ³é¢‘å·²ä¸‹è½½', 'success');
            } catch (error) {
                console.error('ä¸‹è½½å¤±è´¥:', error);
                showStatus(`ä¸‹è½½å¤±è´¥: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>